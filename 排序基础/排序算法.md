# O(n^2)的排序算法

我们知道，对于排序算法来说，最优的时间复杂度是 O(n log n)，也就是线性对数阶O(n log n)，对应的排序算法有：堆排序、**归并排序**、快速排序（最好平均）

## 选择排序Selection Sort

![](../img/impicture_20220214_192424.png)

对于选择排序，我们首先进行第一趟排序，找到这组数据中最下的数，1，然后将1和数组的第一个元素进行交换，得到如下数组，这个时候1就是最小的数，排序位置固定了。

> 1  6  2  3  8  5  7  4

然后我们在剩下的部分找最小的数， 找到 2，将2和数组第二个元素进行交换，得到

> 1  2  6  3  8  5  7  4

然后依次进行下去，直到遍历完所有数据排序完成。

![](../img/impicture_20220214_193308.png)

换一个图表示选择排序

![](../img/v2-c7bbbfaf4e9853595f439e25420197a8_r.jpg)

## ***时间复杂度和稳定性***

选择排序的时间复杂度是：![](../img/equation.svg)假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次因此，选择排序的时间复杂度是 ![](../img/equation.svg)

选择排序是稳定的算法，它满足稳定算法的定义：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！