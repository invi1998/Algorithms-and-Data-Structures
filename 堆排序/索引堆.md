# 索引堆 Index Heap

新来看一下之前的普通的堆有什么问题，然后引出为什么要引入索引堆这种新的数据结构

![](../img/impicture_20220222_162935.png)

首先，我们给定一个数组，然后要将这个数组Heapify（数组建堆），最后构建完成之后，结果就是如下所示。

![](../img/impicture_20220222_163103.png)

对比Heapify前后，发现对于这个数组而言，数组中的元素发生了改变。正是因为这些元素位置的改变，才使得我们能够将现在的这个数组看做是一个堆。可是在我们构建堆的过程中，改变元素的位置会有一些局限性。

首先第一个局限性是，如果我们的元素是非常复杂的对象结构的话，最典型的例子就是比如说我们的元素是字符串的话，那么交换这些元素本身就需要耗费大量的机器性能。（比如我们每个元素都是一篇有10W字的文章的话，那么交换这些巨型字符串对象，会产生大量的性能消耗），不过这种性能消耗还是可以使用技术手段来进行解决的。

另外一个问题相对的就更加致命，由于我们整个元素在这个数组中的位置发生了改变，使得当我们的堆建成以后，很难在索引到它，当我们难以索引到它的时候，我们就很难去该变它。举个例子：比如我们数组中这些元素表示的是一个一个的系统任务，可能在初始的时候，数组的索引表示的是系统进程的id号。可是当我们把这个系统任务数组构建成堆以后，这些任务索引和系统任务之间就不再产生关联了。那如果这个时候，有这么一个需求，那就是我想将原来进程id（索引）为6的这个进程他的优先级提一下，该怎么做呢？这个操作就会变得非常的困难。在以前的数组中，我们可以使用O（1）的性能效率直接将这个任务通过索引提取出来，但是由于我们把它组建成堆以后，元素位置发生了改变，任务和索引之间不在有关联关系。当然也许有人会说，那把这些元素加一个字段表示进程id就好了，那这样是可以解决问题，可是这样做了之后，我们要想拿到某个进程id的任务，就得把这个数组遍历一遍，这样也是低效率的。

为此我们就需要引入索引堆这个概念

## 索引堆概念

![](../img/impicture_20220222_164748.png)

具体什么是索引堆呢？这里依旧以最大索引堆为例

对于索引堆来说，我们将数据和索引这两部分分开存储，而真正表征堆的这个数组是由这个索引构建成的。如上这个数组在图示中构建成的一个二叉树，这个二叉树每一个节点上所存储的是这节点对应的索引号，单我们将这个数组构建成一个堆之后，这个数组就相应的变成了下图这个样子。从图中可以看到，对于data这个域来说，他的内容没有发生改变，而真正改变的是index这个域，这个index数组（索引数组）发生了改变，形成了一个堆。这个堆怎么解读呢？首先看堆顶的元素，index值为10，表示的就是data域中数组索引为10的元素（这里就是62）所在的节点。这样一来我们可以观察到索引堆的两个好处，第一就是构建堆的过程只是索引值发生交换，索引就是一个非常简单的int型，如果他的data是非常复杂的对象类型的话，那么我们交换的时候只交换索引效率是非常高的。第二点也是很重要的一点，如果我们现在想堆这个堆中的某个数据进行操作，我们就可以直接很容易的去索引这个相应的索引号的data数据去进行操作。

![](../img/impicture_20220222_165505.png)

这里也可以很容易的和之前的堆作比较，建立一个堆的过程其实和之前是差不多的，只不过我们在比较的时候是比较索引号对应的data里的元素进行比较，然后交换的时候是使用索引进行交换。

**简单总结**

索引堆是对堆这个数据结构的优化。

索引堆使用了一个新的 int 类型的数组，用于存放索引信息。

相较于堆，优点如下：

- 优化了交换元素的消耗。
- 加入的数据位置固定，方便寻找。

如果堆中存储的元素较大，那么进行交换就要消耗大量的时间，这个时候可以用索引堆的数据结构进行替代，堆中存储的是数组的索引，我们相应操作的是索引。