# 二叉搜索树 Binary Search Tree

之前介绍的堆这种数据结构他的本质也是一个二叉搜索树。通过堆这个例子也可以看出来，二叉树在计算机中是一种非常常见的数据结构。

二分搜索树（英语：Binary Search Tree），也称为 二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件：

- 若它的左子树不为空，左子树上所有节点的值都小于它的根节点。
- 若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。

它的左、右子树也都是二分搜索树。

## 查找问题 Searching Problem

查找问题是计算机中非常重要的基础问题。

## 二分查找法 Binary Search

二分查找法是一种非常常见的查找方式，对于有序数列才能使用二分查找法（这也就体现了之前学习排序算法的作用）

如果我们要查找一元素，先看数组中间的值V和所需查找数据的大小关系，分三种情况：

- 1、等于所要查找的数据，直接找到
- 2、若小于 V，在小于 V 部分分组继续查询
- 2、若大于 V，在大于 V 部分分组继续查询

![img](../img/RsvE28BWbRdtJ7YM.png)

c++代码实现

```c++
// 二分查找法，在有序数组中查找target
// 如果找到target，返回相对应的索引index
// 如果没有找到target，返回-1
template<typename T>
int binarySearch(T arr[], int n, T target)
{
    // 首先申明两个变量,表示我需要在arr[l, r]这个前闭后闭区间内查找target
    int l = 0, r = n-1;
    
    while(l<=r)
    {
        // int mid = (l+r)/2;
        // 注意这里，因为l和r都是int型，如果两个很大的int型相加，是很有可能超过int型的表达范围
        // int型溢出，这个程序就会产生bug
        // 怎么解决这个问题呢？那就不要使用加法，转而使用减法来求这个mid
        int mid = l + (r-l)/2;
        
        if(arr[mid] == target)
        {
            return mid;
        }
        
        // 如果 中间值大于target，就在arr[l, mid-1]范围内继续查找
        if(arr[mid] > target)
        {
            r = mid-1;
        }
        else    // 如果 中间值小于target，就在arr[mid+1, r]范围内继续查找
        {
            l = mid+1;
        }
    }
    
    return -1;
}
```

这里有个很经典的问题就是求中间值的时候int型溢出问题

> `int mid = (l+r)/2;`
> 注意这里，因为l和r都是int型，如果两个很大的int型相加，是很有可能超过int型的表达范围
> int型溢出，这个程序就会产生bug
> 怎么解决这个问题呢？那就不要使用加法，转而使用减法来求这个mid
> `int mid = l + (r-l)/2;

当然也可以实现一个递归版本的二分查找，只不过递归版本的性能一般来说，都会差于迭代版本。

```c++
template<typename T>
int __binarySearch2(T arr[], int l, int r, T target)
{
    if(l>r)
    {
        return -1;
    }
    
    int mid = l + (r-l)/2;
    
    if(arr[mid] == target)
    {
        return mid;
    }
    else if (arr[mid] > target)
    {
        __binarySearch2(arr, l, mid-1, target);
    }
    else
    {
        __binarySearch2(arr, mid+1, r, target);
    }
}


// 递归版本的二分查找法
template<typename T>
int binarySearch2(T arr[], int n, T target)
{
    return __binarySearch2(arr, 0, n-1, target);
}
```

## 二分查找法的变种

### floor 和 ceil 

我们之前的二分查找算法通常来说，都是假设在这个数组中是没有重复元素的，当然我们上面那个二分查找算法对于有重复元素的数组也能找到其索引，只不过这个元素可能会在数组中出现很多次。我们之前的二分查找并不能保证查找到的索引具体的是哪个索引，但是相对应的floor和ceil这两个函数，他们应该能够保证，对于floor来说，找到的是这个元素在数组中第一次出现的位置索引，而如果是调用ceil，那么应该找到的是这个重复元素在数组中最后一次出现的位置

![](../img/impicture_20220223_141500.png)

这两个函数还有一个优势，就是单我们在查找一个不存在的元素的时候，我们之前的实现是直接返回-1，但是我们定义的floor和ceil这两个函数，他们的返回值应该是这样的一个情况，比如在如下这个有序数组中我们要查找42的话，可以看到42在这个数组中是不存在的，那么floor这个函数返回的就应该是最后一个41的元素位置，ceil返回的就应该是第一个43元素出现的位置。

![](../img/impicture_20220223_143022.png)