# 图论 Graph Theory

**图论**是对图的研究，图是用来模拟物体之间两两关系的数学结构。图由顶点、节点或由边、弧或线连接的点组成。

一个图可能是无向的，这意味着与每条边相关的两个顶点之间没有区别，或者它的边可能从一个顶点指向另一个顶点;参见图(离散数学)了解更多详细的定义，以及通常考虑的图类型的其他变化。

![](../img/impicture_20220208_204925.png)

在最普遍的意义上的术语,图是一个有序对G = (V, E)由一组顶点V或节点或边缘点的一组E或弧行,这是2-element V的子集(即一条边与两个顶点相关联,这协会的无序对由两个顶点)。

在一个更广义的概念中，V是一个集合，它与每条边与两个顶点的关联的关联关系。

在另一个广义的概念中，E是一个由无序的(不一定是不同的)顶点组成的多对集合。

V和E通常被认为是有限的，对于无限图，许多众所周知的结果都是不正确的(或者是相当不同的)，因为许多参数在无限情况下失败了。

图的顺序是|V|，它的顶点数。

图的大小是|E|，它的边的数目。

一个顶点的度或价是连接到它的边的数量，其中连接一个顶点到它自身的边(循环)被计数两次。

![](../img/impicture_20220208_205205.png)

在计算机科学中，图被用来表示通信网络、数据组织、计算设备、计算流程等。例如，一个网站的链接结构可以用一个有向图表示，其中顶点表示网页，有向边表示从一个页面到另一个页面的链接。

类似的方法可以应用到社交媒体、旅游、生物、计算机芯片设计和许多其他领域。因此，开发处理图形的算法是计算机科学的主要兴趣所在。

## 图的简单分类

![](../img/impicture_20220208_205524.png)

一个简单的自动机

![](../img/impicture_20220208_205632.png)

无向图可以看成是一种特殊的有向图

![](../img/impicture_20220208_205822.png)

![](../img/impicture_20220208_205857.png)

## 图的连通性

![](../img/impicture_20220208_210003.png)

## 简单图

![](../img/impicture_20220208_210056.png)

## 邻接矩阵（Adjacency Matrix）

邻接[矩阵](https://baike.baidu.com/item/矩阵)（Adjacency Matrix）是表示顶点之间相邻关系的矩阵。设G=(V,E)是一个图，其中V={v1,v2,…,vn} [1] 。G的邻接矩阵是一个具有下列性质的n阶方阵：

①对 **无向图** 而言，邻接矩阵一定是对称的，而且主对角线一定为零（在此仅讨论无向简单图），副对角线不一定为0，**有向图** 则不一定如此。

②在无向图中，任一顶点i的度为第i列（或第i行）所有非零元素的个数，在有向图中顶点i的出度为第i行所有非零元素的个数，而入度为第i列所有非零元素的个数。

③用邻接矩阵法表示图共需要n^2个空间，由于无向图的邻接矩阵一定具有[对称关系](https://baike.baidu.com/item/对称关系)，所以扣除对角线为零外，仅需要存储上三角形或下三角形的数据即可，因此仅需要n（n-1）/2个空间。

​    **邻接矩阵适合表示一个稠密的图（Dense Graph）,边相对较多**

![](../img/impicture_20220208_211143.png)

邻接矩阵表示无向图

   ![](../img/impicture_20220208_210410.png)

邻接矩阵表示有向图

![](../img/impicture_20220208_210551.png)

## 邻接表（Adjacency Lists）

**邻接表适合表示稀疏的图（Sparse Graph），边相对较少**

![](../img/impicture_20220208_211151.png)

单纯从边的多少来判断它是一个稀疏图还是稠密图有点抽象，
如果一个节点和它连接的边远远小于能够与它连接的边的个数，就是稀疏图
稠密图和完全图，完全图就是只所有节点都和其他节点都相互连接

图的邻接表存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的[存储结构](https://baike.baidu.com/item/存储结构)。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。如词条概念图所示，表结点存放的是邻接顶点在数组中的索引。对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。 [1] 

邻接表是图的一种最主要存储结构,用来描述图上的每一个点。对图的每个顶点建立一个容器（n个顶点建立n个容器），第i个容器中的结点包含顶点Vi的所有邻接顶点。实际上我们常用的邻接矩阵就是一种未离散化每个点的边集的邻接表。

在[有向图](https://baike.baidu.com/item/有向图)中，描述每个点向别的节点连的边（点a->点b这种情况）。

在[无向图](https://baike.baidu.com/item/无向图)中，描述每个点所有的边(点a-点b这种情况)

与邻接表相对应的存图方式叫做边集表，这种方法用一个容器存储所有的边。

工业上有很多非常好的图库的实现,例如C++的boost graph库.如果可以，尽量用这些库，这样可以大大提高你的效率。

邻接表表示无向图

![](../img/impicture_20220208_210648.png)

邻接表表示有向图

![](../img/impicture_20220208_210809.png)

## 遍历邻边

![](../img/impicture_20220208_192901.png)

## 图的遍历

### 深度优先遍历

![](../img/impicture_20220210_175529.png)

所谓深度优先，就是从一个点开始，不断的往下试，直到试不下去为止。但是图和树不一样，树因为有根和叶，所以从根玩下走，一定有走不通的时候，但是图不一样，图可能存在上面中的环结构。所以这里对于图，我们就需要记录图中的每一个点是否被遍历过了。如果被遍历过了，我们在后面的遍历中就不需要继续走了。

遍历过程描述：

首先我们从0开始遍历，从左侧邻接表中可以看到，和0相邻的第一个节点是1，所以我们遍历到1

0 - 1

然后看1，和1相邻的只有0，但是0我们已经遍历过了，所以1没有没有遍历过的点，退回到0

然后继续，和0相邻的下一个点是2，我们就遍历到了2，

0 - 1 -2

然后看2，和2相邻的点只有0，零遍历过了，退回到0,继续遍历，和0相邻的下一个点是5, 5没有遍历过，

0 - 1 - 2 - 5

然后看5，和5相邻的 第一个点是0，不遍历，然后继续看还有没有和5相邻的点，有，下一个相邻的是 3, 3没有遍历过

0 - 1 - 2 - 5 - 3

然后继续，看3，和3向邻的第一个点是4,4没有遍历过

0 -1 - 2 - 5 - 3 - 4

然后看4， 和4 相邻的第一个点是3,3遍历过了，跳过，继续看还有没有和4相邻的点，有，5，但是5也遍历过了，继续找，找到6,6没有遍历过

0 -1 - 2 - 5 - 3 - 4 - 6

然后看 6 ，和6相邻的第一点是 0 ，0 遍历过了，继续找，4,4也遍历过了，继续找。没有了，那就回退到4, 看和4相邻的点中还有没有没遍历过的，没有，那就继续回退到3，看和3相邻的还有没有没遍历过的，没有，那就继续回退到5，看和5相邻的点有没有没有遍历过的，没有，继续回退到2，看2有没相邻的点没有被遍历过的，没有，继续回退，回退到1，没有，回退到0.看有没有。没有。至此，一个从 0 开始的深度优先遍历过程就完成了

至此一个连通图一次深度优先就遍历完所有节点了。这种深度优先遍历还有一个作用是求一个图的**连通分量**（如下就是有3个连通分量）

![](../img/impicture_20220210_180958.png)

无向图 G 的一个极大连通子图称为 G 的一个连通分量（或连通分支）。连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量。连通分量与连通分量之间没有任何边相连。深度优先遍历可以用来求连通分量。因为一次深度优先只能遍历一个连通，遍历完整个连通，继续随机选择下一个没有遍历过的点，进行深度优先遍历，如此继续，直到整个图中不存在没有遍历过的点，那么我们就可以确定整个图遍历结束，遍历了几次深度优先，就说明有几个连通分量

#### 获得两点间的一条路径

![](../img/impicture_20220210_204521.png)

回顾上面的深度优先遍历，其实我们在遍历的过程中也形成了上图中红线表示的一条一条的路径。如果我们想获得两点之间的一条路径，其实在遍历过程中文我们都可以通过这个红色的线条找到。比如：

0 - 2 ： 0 2

0 - 5 ： 0 5

5 - 6 ：5 3 4 6

可以看到我们采用深度优先的遍历并不一定能找到最短路径（对于无权图的最短路径问题，下面会进行探讨）本节的目的就是通过深度优先的算法获得一条路径。

我们要做的就是在遍历的过程中存储这条路径，怎么做？很简单，我们只需要在遍历到一个节点的时候，存储我们是从哪个节点遍历到这个节点的即可

![](../img/impicture_20220211_201354.png)

根据我们图的实现方式的不同，我们深度优先遍历的复杂度也会有所不同。

如果我们的图是使用邻接表实现的，那么他的时间复杂度就是O(V+E)，通常情况下E会比V大，所以一帮也会说它是O(E)这个级别的。如果是使用邻接矩阵实现的话，那么它的时间复杂度就是O(V^2)这个级别的。

对于邻接矩阵他的时间复杂度为什么是O(V^2)，是因为当我们要想获得一个节点他的所有相邻的节点的时候，我们需要将这个图中所有的节点都扫一遍，而在邻接表的实现中，对于每一个节点我们首先要访问，而每一个节点他所有相邻的节点就构成了了这张图中总共的边数，也就是说我们将所有的边都访问了一次，没有进行其他多于的访问。

也正是因为如此，如果我们的是一个稀疏图的话，通常是使用邻接表这样的表达方式他的效率会高一些

![](../img/impicture_20220211_202130.png)



#### 广度优先遍历

对于广度优先遍历，我们需要有一个队列进行辅助遍历。

![](../img/impicture_20220211_202838.png)

对于上面这个图，我们使用广度优先遍历的方式，进行遍历的过程描述

首先在遍历之前，我们要将**0**这个初始节点推入到我们的辅助队列**q**中，之后开始我们的遍历过程。

> 辅助队列：q ：0
>
> 遍历结果队列：

在遍历过程中，我们每次都将辅助队列首的元素取出来作为我们的遍历对象。所以这里我们将 **0**取出来进行遍历，这里也就相当于我们遍历了 0 这个节点

> 辅助队列：q ：
>
> 遍历结果队列：0

之后我们要做的就是 将 0 这个节点他所有相邻的节点进行遍历，如果他这些相邻的节点还没有加入过队列（这里加入过队列是指加入到辅助队列和遍历结果队列这两个任意一个），就将这个节点加入到 辅助队列q里

> 辅助队列：q ：1  2  5  6
>
> 遍历结果队列：0

这个时候1， 2， 5， 6这4个和 0 相邻的未遍历过的节点都加入到了这个辅助队列中，然后下一步依旧是取辅助队列中的首个元素，加入到遍历结果队列，作为遍历对象对其进行相邻未加入过的节点进行遍历。

> 辅助队列：q ：2   5  6
>
> 遍历结果队列：0  1

然后1的遍历结果就是没有为添加过队列的节点，那就继续去辅助队列取首个元素 2 ，将2作为遍历对象对其进行遍历。

> 辅助队列：q ：5  6
>
> 遍历结果队列：0  1  2

2的遍历结果和1也是一样的，没有未加入过队列的节点，继续取辅助队列中的下一个首元素 5 ，对5进行遍历， 0加入过了，3没有， 4也没有。把3， 4加入到辅助队列

> 辅助队列：q ：6  3  4
>
> 遍历结果队列：0  1  2  5

然后5遍历完，继续取下一个辅助队列的元素 6，将其作为遍历对象，6的相邻元素 0 已经加入过队列了，跳过，然后是4, 4虽然没在遍历结果队列中，但是4也加入过队列（辅助队列），所以4也不能算，跳过。那至此，6的相邻节点就没有没加入过队列的节点了。（所以这我们在进行编码实现的时候要主要，我们在进行visited标记的时候，应该是对加入过队列进行标记，而不是是否遍历过进行标记，这里要重点注意，因为它只要加入到辅助队列了，早晚都要被处理到）

> 辅助队列：q ：3  4
>
> 遍历结果队列：0  1  2  5  6

然后继续取辅助队列中的首个元素 3，遍历3的相邻节点，发现 4 在队列中，跳过，然后是 5,5遍历过，也跳过。

> 辅助队列：q ：4
>
> 遍历结果队列：0  1  2  5  6  3

然后继续取辅助队列中的首个元素 4,遍历4中的相邻节点，3， 5， 6都已经遍历过了，跳过

> 辅助队列：q ：
>
> 遍历结果队列：0  1  2  5  6  3  4

然后继续取辅助队列中的首元素，发现没有，至此一个广度优先遍历就结束了。遍历结果就是 **0  1  2  5  6  3  4**

可以感受一下这个整个广度优先遍历的过程，对于这张图而言，实际上是以距离我们遍历的起始点 0 的距离为顺序进行遍历的。首先0这个节点自己到自己的距离最短，所以0优先被遍历到，之后0所有相邻的节点都被推了进去，也就是 1 2 5 6这4个节点。他们距离0的距离都是1。接下来我们在遍历5的时候将3， 4这两个节点进行了遍历，而3 4这两个节点他们距离0的距离是2。所以从这个角度看，广度优先遍历又被称为层序的优先遍历。就是从遍历的起始点开始，一层一层的往下遍历，先遍历到的点距离起始点会近一些，而后遍历到的点会距离起始点会远一些。但是这里也需要注意，所谓的先后也是存在并列关系的，比如1， 和 6，它们距离0的距离都是1，所以更严谨的说法就是先遍历到的点距离起始点的距离一定是小于等于后遍历到的点

我们在程序中遍历的时候，其实也可以记录这个距离。当我们记录这个距离之后，我们就求出了在这个无权图中，每一个节点距离我们起始节点它的最短距离。不仅如此，如果我们像深度优先遍历一样，使用一个from数组来记录每一个节点是从哪一个节点遍历过来的，我们还能将最短距离背后的这个最短路径求出来。其实这也是图使用广度优先遍历最重要的一个应用。

![](../img/impicture_20220211_210504.png)

这个作用于有向图和无向图的无权图。对于有权图，后面会探讨。

![](../img/impicture_20220212_110113.png)

---

# 带权图（Weighted Graph）

![](../img/impicture_20220212_110551.png)

## 邻接矩阵表示一个有权图

![](../img/impicture_20220212_111159.png)

对于邻接矩阵，之前我们表示无权图的时候，矩阵的值是使用0-1表示节点之间是否存在边，现在只需要将这个这些边改为保存权值就可以了

## 邻接表表示一个有权图

![](../img/impicture_20220212_111803.png)

对于邻接表来说，会有所不同，因为之前我们用邻接表存的是节点到与它相邻的节点的索引，但是现在因为有了权值，所以此时我们每个节点后面应该存储两个信息，一个是与它相邻的节点索引to，一个是到该节点边的权重w。这样一表达，我们很容易看出来，这里我们不能用一个简单的数据类型。为此我们应该给他封装成一个类，这里就叫他 Edge （边）。

那这里如果我们的邻接表这样存的话，那么为了保证邻接表和邻接矩阵这二者具有统一的接口，为此最好的情况就是，邻接矩阵中`a[i][j]`中每一个元素的位置我们都给他存为一个 Edge 。也就是我们邻接矩阵中，每一个边用一个类Edge来表达，对于没有边的 0 来说，就可以用NULL来表达

## 最小生成树问题（Minimum Span Tree）

我们要研究的第一个有权图算法就是最小生成树问题

![](../img/impicture_20220212_151452.png)

对于这样一个完全连通的带权图来说，我们可不可以找到一个这个图所属的生成树（如上红线部分），一张图如果有V个节点的话，那么相对应的就应该使用v-1条边，这V-1条边连接了V个节点，我们就说它是这个图的生成树。而这棵生成树不但连接了图中的所有节点，与此同时这棵生成树上所有边的权值之和也是所有生成树中最小的。我们如何找到这样一颗生成树就是最小生成树的问题。

> 最小生成树问题通常是针对 带权无向图，针对连通图 而言的。
>
> 而对于一个不连通的图来说，我们也可以求出每个连通分量的最小生成树，这样的一个最小生成树集合也被称为最小生成森林

下面会介绍两个最小生成树的算法，这两个算法都不约而同的都应用了这样一个定理（切分定理）这里先介绍什么是切分定理，后续会介绍如何利用切分定理求最小生成树的两个思路。

### 切分定理（Cut Property）

在介绍切分定理之前，首先要先明白什么是切分。如果我们把图中的节点分为两个部分，这样分我们就说这个图形参了一个切分。比如下图中的蓝色部分和红色部分就形成了一个切分。

![](../img/impicture_20220212_152614.png)

在我们定义了一个图的切分之后，我们就可以定义一个新的概念 - 横切边。横切边是什么意思？如果一个边他的两个端点属于切分的不同的两边，（比如在下面这个图中，如果一个边它的一端是这种蓝色的节点，另一端是这种红色的节点）这样的边就被称为横切边。

![](../img/impicture_20220212_152825.png)

有了这些前置补充，我们就能描述切分定理了，**切分定理：描述的是这样一个事实，在一张图中，我们给定任意的一个切分，在这些横切边中，权值最小的边必然属于这张图中的最小生成树中的某一个边。**

![](../img/impicture_20220212_153748.png)

有了这个定理，我们就可以从一个顶点，利用切分定理，逐步向其他节点扩散，逐步求出一个完整的最小生成树。

## Lazy Prim

根据切分定理设计第一个最小生成树算法。

![](../img/impicture_20220212_154847.png)

如上所示，有一个带权连通图。我们首先将一个起始节点，这里将 0 作为起始节点，将它作为切分的一部分，而剩下的作为切分的另外一部分。这样一来我就画出了一个切分，根据这个切分，我们就得到了如下的横切边。每一次我们要做的事情就是找到这些横切边中最短的哪边。这里我们就可以使用一个数据结构啦非常快速的做这个事情 - 最小堆。也就是我们将这些蓝色的边放入到最小堆中作为最小生成树的包含的边的候选

![](../img/impicture_20220212_162101.png)

接下来只需要拿出这些候选边中的最短边就可以，这个时候在蓝色的候选边中，权值最小的边是 0 -7 边

![](../img/impicture_20220212_162143.png)

然后这个时候我们确定0 - 7这个边是最小生成树的边，而7这个节点没有被访问过，那么我们就把7加入到我们的红色切分中来。然后这个时候就形成了一个新的切分。形成了一个新的切分就加入了新的顶点，那么这个时候这个新的顶点7就和其他顶点之间形成了新的横切边。这个时候我们把这些横切边加入到候选边（蓝色 最小堆）中来

![](../img/impicture_20220212_162307.png)

然后从这个最小堆中（蓝色）选出权值最小的边。这个时候最小的边是 1 - 7 的边，根据切分定理，这条边一定属于最小生成树，所以我们把 1-  7标红，同时1没有被访问过，所以把1也加入到红色切分中来。

![](../img/impicture_20220212_162704.png)

因为1加入到红色切分中，所以我们又形成了新的横切边。我们把这些横切边加入到最小堆（蓝色）中来

![](../img/impicture_20220212_162949.png)

然后我们继续看在我们这些候选边中，最短的边是 0 - 2 这条边，根据切分定理，这条边一定属于最小生成树，把 0 -2 标红，同时2没有被访问过，把2加入到红色切分中来。同时这个时候因为2加入切分，所以又有了新的横切边，我们把它加入到最小堆中（蓝色）

![](../img/impicture_20220212_163306.png)

这里我们注意到，当我们把2这个节点加入到红色切分后，现在我们这些蓝色的最小堆（边）中，连接2 - 7的和连接1-2的这两条边实际上已经不是横切边了。所以从道理上讲，这两条边就已经不应该成为我们最小生成树的边的候选了。在这里也就体现出来我们这个算法（Lazy Prim）中的lazy低效率的地方了。当前这个实现中，虽然这两条边已经不可能是最小生成树的候选，但是我们并不急着把它剔除出我们的候选边，换句话说就是我们的最小堆中依然保持着这两条边。当我们拿出这两条边的时候，发现这他们的两个顶点都在同一个切分（也就是他本身已经不是一个横切边的时候），那个时候我们再直接把这个边扔掉就好了。

然后下面我们继续从最小堆中取出我们的最小边，此时最小的是2-3的这条边，根据切分定理，这个边就是最小生成树的一条边，那么相应的3这个节点就可以加入到我们的红色切分中。

![](../img/impicture_20220212_164132.png)

这时候和3相邻的这条3-6边也可以加入到我们的最小堆中（横切边）。

![](../img/impicture_20220212_164333.png)

然后这个时候我们再继续查看我们的最小堆，找最小边，发现5 - 7这个边权值最小，根据最小生成树原理，这条边一定是最小生成树的边，加入标红。同时与5相邻的5-4也就可以加入到候选边（最小堆）中来。

![](../img/impicture_20220212_164621.png)

然后我们在最小堆中继续找最小边，发现 0.29是最小边，但是这个时候注意，这条边他的两个顶点1 3都已经访问过了，换句话说，这条边其实并不是一个横切边，所以这条边抛弃跳过。继续寻找，同样的1- 5 ， 2 -7这两条最短边也都不是横切边，所以都跳过，继续找 4 - 5这条边，4没有被访问过，4-5是横切边，所以加入到红色切分中，

![](../img/impicture_20220212_165029.png)

同样的，将4 - 6加入到最小堆中，遍历查找最小边，然后判断是否是横切边，不是就跳过继续，直到找到2-6这条最小横切边，将2-6标红，同时6加入到红色切分。

![](../img/impicture_20220212_165137.png)

其实，到此为止，我们的最小参数以及找到了，但是如果我们是以最小堆是否为空为终止条件，那么我们就还需要继续遍历查找最小堆中的数据，只不过我们此时拿出来的边肯定都不会是横切边了。所以都是拿出来判断一下，然后扔掉。此时我们的算法就算是正真结束了，我们就获得了这个连通图的最小生成树。

```c++
template<typename Graph, typename Weight>
class LazyPrimMST
{

private:
  Graph &G;
  MinHeap<Edge<Weight>> pq;  // 这个最小堆充当一个优先队列，在这个优先队列中，存储的是这个图中的边（确切的说是最小生成树的候选边）
  // 首先，我们在划分切分的时候，需要将我们的顶点一个一个的划分到另一边去，marked[i]表示这个点是否被标记了
  // 如果被标记了，就表示被划分到另外一个切分区去了（相当于文档中节点一个一个从蓝色变成了红色）
  bool* marked;
  // 除此之外，我们求出来的最下生成树就是就是一个一个边，我们将这些边放入到一个容器中
  // 在这个容器中，每一个元素都是Edge<Weight>这样的边类型
  std::vector<Edge<Weight>> mst;
  // 最后对于我们最小生成树的相应权值，我们用mstWeight来存储
  Weight mstWeight;

  void visit(int v)
  {
    // 我们访问v这个节点，首先我们得保证，v这个节点他是一个对应在文档里的蓝色节点
    // 也就是marked这个标记里没标记过这个节点
    assert(!marked[v]);
    // 之后访问到了这个节点，就把它的marked设置为true
    marked[v] = true;
    // 之后要做的就是遍历这个红色的节点他的所有临边（也就是v节点的所有邻边）
    typename Graph::adjIterator adj(G, v);
    for(Edge<Weight>* e = adj.begin(); !adj.end(); e = adj.next())
      {
        // 我们依次访问v这个节点的所有邻边，一旦我们发现，v这个节点他的邻边对应的另外一个节点，没有被marked标记上，那么这条邻边就是一个 横切边 
        if(!marked[e->other(v)])
        {
          // 找到了一条横切边，那么就意味着我们可以将这条边放入我们的堆中，作为我们的最小生成树的候选边
          pq.insert(*e);
        }
      }
  }

public:
  // 注意这里这个最小堆的初始化，这里给最小堆数组开的空间大小是这个图的边数这么大的空间（也就是说，在最差的情况下，我们的这个图中所有的边都会放进这个最小堆中）
  LazyPrimMST(Graph &graph):G(graph), pq(MinHeap<Edge<Weight>>(graph.E()))
  {
    // 为marked开空间，空间大小是顶点个数
    marked = new bool[G.V()];

      // 给marked开辟好空间以后，我们给这个marked赋予初值
    for(int i = 0; i<G.V(); i++)
      {
        marked[i] = false;
      }
    mst.clear();

    // lazy prim
    // 首先我们visit(0)这个节点，也就是把0先marked，将其作为最小生成树的起始点
    // 将0这个节点的所有邻边（横切边）加入到最小生成树的候选堆中
    visit(0);
    // 然后以最小生成树的候选堆是否为空为判断依据，换句话说，如果我们的优先队列它还不为空的话，
    // 我们就继续遍历
    while(!pq.isEmpty())
      {
        // 每次我们从最小堆中取出一个最小的元素（边）
        Edge<Weight> e = pq.extractMin();

        // 因为我们是lazyPrim，所以有可能我们取出来的这个边，它根本就不是横切边， 所以我们需要判断这条边它是否是一个横切边
        if(marked[e.w()] == marked[e.v()])
        {
          // 如果我们取出来的这条边它相应的两个顶点的marked标记相同的话，说明这条边的两个顶点都被访问过了
          // 那么这条边就不是一个横切边,那么我们就继续while循环，跳过这个边，不用管这个e
          continue;
        }
        else
        {
          // 否者的话，我们取出来的这条边就是一条最小生成树的边
          mst.push_back(e);
        }

        // 此时，对于e这条最小生成树的组成边来说，我们需要找到它这条边新加入区分的那个顶点，进行后续遍历
        if(!marked[e.v()])
        {
          // 如果marked[e.v()]是false，表示他就是那个蓝色点，我们就应该从这个新点开始继续下一轮的visit,把这个新点的所有横切边加入到最小堆（优先队列中来）
          visit(e.v());
        }
        else  // !marked[e.w()]
        {
          // 否者的话,e.v()不是false，那么e.w()就是false，那么我们就把e.w()的横切边加入到优先队列中去
          visit(e.w());
        }
      }

    // while 之后，我们就得到了最小生成树，这个时候，我们只需要对最小权值进行计算，计算完成之后，本函数功能就齐备了
    mstWeight = mst[0].wt();
    for(auto iter = mst.begin(); iter != mst.end(); ++iter)
      {
        mstWeight += (*iter).wt();
      }
  }

  ~LazyPrimMST()
  {
    delete[] marked;
  }

  std::vector<Edge<Weight>> mstEdges()
  {
    return mst;
  }

  Weight result()
  {
    return mstWeight;
  }

};
```

然后我们使用两种图的表现方式来分别测试求出图的最小生成树。

![](../img/impicture_20220228_142003.png)

可以看到，对于同一张图来说，不管我们是使用邻接矩阵还是使用邻接表，他们最终求出的最小生成树都是一样的（这也验证了我们算法实现的正确性）