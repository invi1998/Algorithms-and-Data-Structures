#ifndef HEAP_SORT_H
#define HEAP_SORT_H

#include <iostream>

using namespace std;

// 现在这个shiftDown操作就运行在arr这个数组中前n个元素所定义的这个堆中，然后尝试向下移动k这个索引位置的元素
// 去找到它合适的位置
template <typename T>
void __shiftDown(T arr[], int n, int k)
{
  // 我们什么时候应该继续进行shiftDown操作呢？
  // 首先k这个索引所在的节点应该有孩子。怎么判断有孩子？在一个完全二叉树中，只要他有左孩子，那么我就能确定它有孩子
  // 这是因为在一个完全二叉树中它不可能只有右孩子没有左孩子
  // 这从0开始索引和之前从1开始索引不同之处就来了，这里左孩子就变成了 2*k+1
  while ((2 * k + 1) < n)
  {
    // 在这种情况下，我们要做的事情就是比较它的两个左右孩子，谁大和谁换。
    // 这个时候要注意，有可能这个节点没有右孩子。所以这里需要把这个边界情况考虑上

    // 为此我这里设置一个新的变量索引为j，j初始化成 2*k+1,这个j表示扫描意思呢？
    // 表示在此轮循环中，arr[k]这个元素应该和arr[j]这个位置元素交换
    // 因为它有左孩子，所以就有可能是和左孩子交换位置，这个就是初始化的值为 2*k+1
    int j = 2 * k + 1;

    // 之后我们就判断一下它有没有右孩子，他的右孩子表示成 j+1 就可以了
    // 如果j+1<=count，说明它有右孩子，然后在右孩子存在的基础上比较两个左右孩子的大小
    if (j + 1 < n && arr[j + 1] > arr[j])
    {
      // 如果右孩子比左孩子大，那么这里就把j更新成j+1.
      // 因为j是要进行交换的索引，注意这里谁大谁就是要交换的值
      j = j + 1;
    }
    // 继续判断，单前k节点是否比他要进行交换的子节点小，小就交换
    if (arr[k] < arr[j])
    {
      swap(arr[k], arr[j]);
      // 交换完成之后，我们k这个索引就变到了j这个位置
      k = j;
    }
    else
    {
      break;
    }
  }
}

// 原地堆排序 算法
template <typename T>
void heapSort(T arr[], int n)
{
  // 对于这个堆排序，我们首先需要进行一次heapify 数组建堆
  // 这个heapify就是从非叶子节点开始，注意，这里因为我们这个堆数组是从0开始索引
  // 所以第一个非叶子节点就是（n-1）/2，以及循环终止的位置是0
  for (int i = (n - 1) / 2; i >= 0; i--)
  {
    __shiftDown(arr, n, i);
  }

  // 经过上面的循环，我们就将这个数组arr构建成了一个最大堆
  // 接下来要做的就是倒序的从n-1号索引开始，截至到>0,也就是截至到1号索引的时候进行交换，然后建堆
  // 的重复操作，到0的时候，因为只有一个元素了，就不再需要进行位置交换了
  for (int i = n - 1; i > 0; i--)
  {
    // 在这个过程中，我们首先需要做的就是将arr[0]这个位置的元素和arr[i]这个位置的元素进行交换
    swap(arr[0], arr[i]);
    // 也就是把单前堆中最大的元素交换到数组的末尾它合适的位置中
    // 之后就可以使用shiftDown操作对arr[0, i-1]的部分进行键堆操作
    // 这个时候对于__shiftDown这个函数来说，他的操作数组元素个数就变成i，依旧是从0索引开始进行shiftDown
    __shiftDown(arr, i, 0);
  }

  // 然后经历上面这个过程就完成了堆排序
}

#endif