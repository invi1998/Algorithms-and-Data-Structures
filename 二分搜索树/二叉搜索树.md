# 二叉搜索树 Binary Search Tree

之前介绍的堆这种数据结构他的本质也是一个二叉搜索树。通过堆这个例子也可以看出来，二叉树在计算机中是一种非常常见的数据结构。

二分搜索树（英语：Binary Search Tree），也称为 二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件：

- 若它的左子树不为空，左子树上所有节点的值都小于它的根节点。
- 若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。

它的左、右子树也都是二分搜索树。

## 查找问题 Searching Problem

查找问题是计算机中非常重要的基础问题。

## 二分查找法 Binary Search

二分查找法是一种非常常见的查找方式，对于有序数列才能使用二分查找法（这也就体现了之前学习排序算法的作用）

如果我们要查找一元素，先看数组中间的值V和所需查找数据的大小关系，分三种情况：

- 1、等于所要查找的数据，直接找到
- 2、若小于 V，在小于 V 部分分组继续查询
- 2、若大于 V，在大于 V 部分分组继续查询

![img](../img/RsvE28BWbRdtJ7YM.png)

c++代码实现

```c++
// 二分查找法，在有序数组中查找target
// 如果找到target，返回相对应的索引index
// 如果没有找到target，返回-1
template<typename T>
int binarySearch(T arr[], int n, T target)
{
    // 首先申明两个变量,表示我需要在arr[l, r]这个前闭后闭区间内查找target
    int l = 0, r = n-1;
    
    while(l<=r)
    {
        // int mid = (l+r)/2;
        // 注意这里，因为l和r都是int型，如果两个很大的int型相加，是很有可能超过int型的表达范围
        // int型溢出，这个程序就会产生bug
        // 怎么解决这个问题呢？那就不要使用加法，转而使用减法来求这个mid
        int mid = l + (r-l)/2;
        
        if(arr[mid] == target)
        {
            return mid;
        }
        
        // 如果 中间值大于target，就在arr[l, mid-1]范围内继续查找
        if(arr[mid] > target)
        {
            r = mid-1;
        }
        else    // 如果 中间值小于target，就在arr[mid+1, r]范围内继续查找
        {
            l = mid+1;
        }
    }
    
    return -1;
}
```

这里有个很经典的问题就是求中间值的时候int型溢出问题

> `int mid = (l+r)/2;`
> 注意这里，因为l和r都是int型，如果两个很大的int型相加，是很有可能超过int型的表达范围
> int型溢出，这个程序就会产生bug
> 怎么解决这个问题呢？那就不要使用加法，转而使用减法来求这个mid
> `int mid = l + (r-l)/2;

当然也可以实现一个递归版本的二分查找，只不过递归版本的性能一般来说，都会差于迭代版本。

```c++
template<typename T>
int __binarySearch2(T arr[], int l, int r, T target)
{
    if(l>r)
    {
        return -1;
    }
    
    int mid = l + (r-l)/2;
    
    if(arr[mid] == target)
    {
        return mid;
    }
    else if (arr[mid] > target)
    {
        __binarySearch2(arr, l, mid-1, target);
    }
    else
    {
        __binarySearch2(arr, mid+1, r, target);
    }
}


// 递归版本的二分查找法
template<typename T>
int binarySearch2(T arr[], int n, T target)
{
    return __binarySearch2(arr, 0, n-1, target);
}
```

## 二分查找法的变种

### floor 和 ceil 

我们之前的二分查找算法通常来说，都是假设在这个数组中是没有重复元素的，当然我们上面那个二分查找算法对于有重复元素的数组也能找到其索引，只不过这个元素可能会在数组中出现很多次。我们之前的二分查找并不能保证查找到的索引具体的是哪个索引，但是相对应的floor和ceil这两个函数，他们应该能够保证，对于floor来说，找到的是这个元素在数组中第一次出现的位置索引，而如果是调用ceil，那么应该找到的是这个重复元素在数组中最后一次出现的位置

![](../img/impicture_20220223_141500.png)

这两个函数还有一个优势，就是单我们在查找一个不存在的元素的时候，我们之前的实现是直接返回-1，但是我们定义的floor和ceil这两个函数，他们的返回值应该是这样的一个情况，比如在如下这个有序数组中我们要查找42的话，可以看到42在这个数组中是不存在的，那么floor这个函数返回的就应该是最后一个41的元素位置，ceil返回的就应该是第一个43元素出现的位置。

![](../img/impicture_20220223_143022.png)

```c++
// 二分查找法, 在有序数组arr中, 查找target
// 如果找到target, 返回第一个target相应的索引index
// 如果没有找到target, 返回比target小的最大值相应的索引, 如果这个最大值有多个, 返回最大索引
// 如果这个target比整个数组的最小元素值还要小, 则不存在这个target的floor值, 返回-1
template<typename T>
int floor(T arr[], int n, T target){

    assert( n >= 0 );

    // 寻找比target小的最大索引
    int l = -1, r = n-1;
    while( l < r ){
        // 使用向上取整避免死循环
        int mid = l + (r-l+1)/2;
        if( arr[mid] >= target )
            r = mid - 1;
        else
            l = mid;
    }

    assert( l == r );

    // 如果该索引+1就是target本身, 该索引+1即为返回值
    if( l + 1 < n && arr[l+1] == target )
        return l + 1;

    // 否则, 该索引即为返回值
    return l;
}


// 二分查找法, 在有序数组arr中, 查找target
// 如果找到target, 返回最后一个target相应的索引index
// 如果没有找到target, 返回比target大的最小值相应的索引, 如果这个最小值有多个, 返回最小的索引
// 如果这个target比整个数组的最大元素值还要大, 则不存在这个target的ceil值, 返回整个数组元素个数n
template<typename T>
int ceil(T arr[], int n, T target){

    assert( n >= 0 );

    // 寻找比target大的最小索引值
    int l = 0, r = n;
    while( l < r ){
        // 使用普通的向下取整即可避免死循环
        int mid = l + (r-l)/2;
        if( arr[mid] <= target )
            l = mid + 1;
        else // arr[mid] > target
            r = mid;
    }

    assert( l == r );

    // 如果该索引-1就是target本身, 该索引+1即为返回值
    if( r - 1 >= 0 && arr[r-1] == target )
        return r-1;

    // 否则, 该索引即为返回值
    return r;
}
```

# 二分搜索树 Binary Search Tree

首先我们先来看看为什么要使用二分搜索树。通常来说，二分搜索树这种结构一般都是用于实现一种叫做 查找表 的数据结构。有些地方也将这种数据结构称为 字典 。对于这些数据而言，都是一个一个这种键值对的形式（key-value）数据对。给定一个键值就有与之对应的value值，这样大量的数据对集合在一起就形成了一张表，这个表就被称为查找表。现在通过一个键，就能查找到与这个键对应的值。

![](../img/impicture_20220223_144330.png)

这里也很容易看出来，如果我们的这些key的值都是整数，而且他们的范围比较小，那么我们使用数组就可以直接很轻松的使用索引来找到相应的value值，可是实际在我们的业务逻辑中，很多时候不能用整数来表达这样的键值，或者他这个键的值相对比较稀疏，我们使用数组在空间上并不比较经济，或者我们的key的值就不能使用整数来表示等等诸多限制。在这个时候我们就不能使用数组而需要实现一个查找表。

**实现查找表最基本的一个方式就是实现一个二分搜索树**

![](../img/impicture_20220223_145300.png)

当然，我们要想实现一个查找表也可以使用一个简单的数组或者顺序数组来进行实现，不过通过上面的图例也可以看到，如果我们使用普通数组或者顺序数组来实现查找表的话，使用普通数组，查找一个元素或者插入一个元素，或者删除一个元素就都需要从头到尾遍历一遍。而对于顺序数组实现查找表，查找元素我们可以使用上面的二分查找法，使用O(log n)的时间复杂度完成，但是对于插入和删除元素，依旧需要从头到尾遍历一遍元素。

而相对而言，使用二分搜索树实现查找表就高效很多，他能保证查找，插入，删除这三个元素他们的时间复杂度都近乎是O(log n)。

![](../img/impicture_20220223_150040.png)

## 二分搜索树定义

首先，二分搜索树它依旧是一棵二叉树，除了它是一棵二叉树之外，它还满足如下两个条件

它的每个节点的键值都大于左孩子，同时每个节点的键值都小于右孩子。使用整体上来说，对于每一个节点来说，这个节点的值将会大于它左子树上所有节点的值，同时也会小于它右子树上所有节点的值。（这是二分搜索树一个非常重要的性质）

以左右孩子为根的子树任然为二分搜索树。

> 比如图例中，对于根节点28，它大于左孩子16，小于右孩子30，对于16这个节点，它大于左孩子13，小于右孩子22，等等。。。

![](../img/impicture_20220223_150219.png)

对于他的每一个节点来说，以他的左孩子为根的左子树和以右孩子为根的右子树这两个子树也是两个二分搜索树。从二分搜索树的定义中可以看出来，二分搜索树的定义中，天然的就包含了递归结构。

之前将堆的时候，提到堆中的二叉树是一个完全二叉树，但是对于二分搜索树来说，是没有这个限制的。换句话说，如下的一棵二叉树，也是一个二分搜索树。也就是说，二分搜索树不一定是一棵完全二叉树。

![](../img/impicture_20220223_151237.png)

我们之前在实现堆的时候，就是因为完全堆是一个完全二叉树，所以能够用数组来进行实现，但是由于我们的二分搜索树不一定是一个完全二叉树，所以用数组表示并不方便。所以对于二分搜索树来说，通常是设立node节点来表示key，value这样的一个数据对。这些节点之间的联系我们使用指针或者引用的形式来表示。（c++中通常也就是使用指针来表示）。同时这里有一个点需要注意，在观察我们上面提供的这些图可以看到，二分搜索树中，每一个节点上都只显示了一个值，这个值通常是表示键这个值。对于每一个键相对应的按个value信息，由于这个信息是查找的时候使用的，所以在表征这棵树的节点的时候，不把它表征出来。这些细节在具体的代码实现中注意体会。