# O(n^2)的排序算法

我们知道，对于排序算法来说，最优的时间复杂度是 O(n log n)，也就是线性对数阶O(n log n)，对应的排序算法有：堆排序、**归并排序**、快速排序（最好平均）

## 选择排序Selection Sort

![](../img/impicture_20220214_192424.png)

对于选择排序，我们首先进行第一趟排序，找到这组数据中最下的数，1，然后将1和数组的第一个元素进行交换，得到如下数组，这个时候1就是最小的数，排序位置固定了。

> 1  6  2  3  8  5  7  4

然后我们在剩下的部分找最小的数， 找到 2，将2和数组第二个元素进行交换，得到

> 1  2  6  3  8  5  7  4

然后依次进行下去，直到遍历完所有数据排序完成。

![](../img/impicture_20220214_193308.png)

换一个图表示选择排序

![](../img/v2-c7bbbfaf4e9853595f439e25420197a8_r.jpg)

## ***时间复杂度和稳定性***

选择排序的时间复杂度是：![](../img/equation.svg)假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次因此，选择排序的时间复杂度是 ![](../img/equation.svg)

选择排序是稳定的算法，它满足稳定算法的定义：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！



## 插入排序Insertion Sort

插入排序(InsertionSort)，一般也被称为直接插入排序。

对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表

。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

插入排序的平均时间复杂度也是 **O(n^2)**，空间复杂度为常数阶 **O(1)**，具体时间复杂度和数组的有序性也是有关联的。

插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 **N-1** 次，时间复杂度为 **O(N)**。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。

### 过程图示

假设前面 **n-1**(其中 **n>=2**)个数已经是排好顺序的，现将第 **n** 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。

按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。

从小到大的插入排序整个过程如图示：

**第一轮：**从第二位置的 6 开始比较，比前面 7 小，交换位置。

![img](../img/InsertSort-01.png)

**第二轮：**第三位置的 9 比前一位置的 7 大，无需交换位置。

![img](../img/InsertSort-02.png)

**第三轮：**第四位置的 3 比前一位置的 9 小交换位置，依次往前比较。

![img](../img/InsertSort-03.png)

**第四轮：**第五位置的 1 比前一位置的 9 小，交换位置，再依次往前比较。

![img](../img/InsertSort-04.png)

......

就这样依次比较到最后一个元素。

```c++
// 插入排序

template<typename T>
void insertionSort(T arr[], int n)
{
    // 注意这里，插入排序第一层遍历从1开始，为什么？
    // 因为对于插入排序来说，第0个元素我们根本可以不用考虑
    // 因为对于插入排序来说，第0个元素放在那里，它本身就已经有序了
    // 我们不再需要把它插入到前面的任何一个位置(第0个元素前面也没有位置)
    // 所以我们开始遍历的时候是直接从第二个元素(索引值为1这个元素开始考察的)
    for(int i = 1; i < n; i++)
    {
        // 然后在这个循环里我们做的事情是什么？
        // 寻找元素arr[i]合适的插入位置
        // 这个合适的插入位置是在前面
        // 所以这里这层循环我们是从这个位置向前倒。知道j>0为止
        // 注意这里是j>0而不是j>=0,为什么？
        // 因为我们这层循环是和当前元素的前一个位置元素进行比较，看看能不能放在前一个元素的位置
        // 可以想象，这个比较最后发生的位置，应该是j = 1的时候，这个时候就是位置1的元素和位置0的元素做比较
        // 看位置1能不能插入到位置0，如果能，就交换位置
        // 所以我们最多考察到j=1这个位置（也就是j>0）
        
        // for(int j = i; j > 0; j--)
        // {
        //     if(arr[j] < arr[j-1])
        //     {
        //         swap(arr[j], arr[j-1]);
        //     }
        //     // 如果在这里我们已经发现j这个位置的元素已经大于等于它前面位置的元素，
        //     // 那么就没有必要继续遍历比较下去了，j这个位置已经是合适的位置了
        //     // 这个时候直接终止这次循环就可以了
        //     else
        //     {
        //         break;
        //     }
        // }
        
        // 所以这里也可以看到插入排序理论上比选择排序效率高的一个表现就是插入排序它是有提前结束遍历的条件的
        // 而选择排序则没有，需要完整跑完全部数据
        
        // 其实这里也可以直接这样写
        for(int j = i; j>0 && arr[j] < arr[j-1]; j--)
        {
            swap(arr[j], arr[j-1]);
        }
    }
}
```



插入排序理论上比选择排序效率高的一个表现就是插入排序它是有提前结束遍历的条件的，而选择排序则没有，需要完整跑完全部数据，但是实际测试下来发现插入排序却比选择排序慢了近一倍。这又是为什么？？

```c++
int n = 100000;
    // int n = 10000;
    int *arrTest1 = SortTestHelper::gennerateRandomArray(n, 0, n);
    int *arrTest2 = SortTestHelper::copyIntArray(arrTest1, n);
    SortTestHelper::testSort("选择排序（Selection sort）", SelectionSort, arrTest1, n);
    SortTestHelper::testSort("插入排序（Selection sort）", insertionSort, arrTest2, n);
    
    // 选择排序（Selection sort） : 14.6116 s 
    // 插入排序（Selection sort） : 30.4101 s 
    
    delete[] arrTest1;
    delete[] arrTest2;
```

插入排序从代码里看到，它是可以提前终止第二层循环的，可是实际运行的时候发现，可是实际上现在这种实现插入排序性能比选择排序性能还要差。

从代码里可以看到，我们现在实现的这个版本的插入排序，它在遍历的同时也在不停的进行交换，交换这个操作是要比简单的比较这个操作还要耗时的，因为每次交换背后都有三次赋值的操作，那这里我们能不能改变插入排序的算法，让他只在内层循环中只交换一次呢？

![](../img/impicture_20220215_194119.png)

比如单前这个数组进行排序，8第0个元素，位置不变，已经是有序的了，看6这个第二个元素，在对6进行排序的时候，我们先不贸然的直接和前面的8进行交换，而是先将这个6复制一份保存起来，然后看6这个元素是不是应该放在单前这个位置，那看他是不是适合放在单前这个位置的方法和之前插入排序是一样的，就是和它前一个值进行比较，现在6比8小，说明6不应该放在单前这个位置，而8应该放在单前这个位置。

![](../img/impicture_20220215_194603.png)

之后再来考察6是不是应该放在前一个位置，此时6所在的位置已经是第0个位置了，所以6就应该放在这个位置。此时6, 8两个值排序完成，下面我们继续排序2，第三个位置的元素。依然是将2这个元素复制一个副本，之后来考察2是不是应该放在这个位置，2比前面的8小，所以2不应该放在这个位置，那我们把这个位置的值赋值成前一个位置的值8，![](../img/impicture_20220215_194855.png)

之后来考察2是不是应该放在原来8所在的位置，发现这个时候原来8所在位置的前一个位置6比2大，所以2也不该放在原来8的位置，那么将原来8所在位置的前一个位置6复制到原来8所在的位置，然后看2是不是适合放在原来6所在的位置，发现是第0个元素，那就直接放在原来6所在的位置。

![](../img/impicture_20220215_195212.png)

同理对于后面的3也是一样，开始先拷贝一个3出来，和前一个进行比较，如果比他小，前一个的值往后拷贝，然后继续前移比较，直到前一个值比这个3小，那就将3放在这个位置上。

可以看到，这整个过程其实逻辑是和之前插入排序是一样的，只不过这里把一次又一次的交换操作变成了比较后做一次赋值。（一次交换就是3次赋值，现在把那么多次交换完全通过赋值给取代了），所以性能会更优。

```c++
// 插入排序

template<typename T>
void insertionSort(T arr[], int n)
{
    // 注意这里，插入排序第一层遍历从1开始，为什么？
    // 因为对于插入排序来说，第0个元素我们根本可以不用考虑
    // 因为对于插入排序来说，第0个元素放在那里，它本身就已经有序了
    // 我们不再需要把它插入到前面的任何一个位置(第0个元素前面也没有位置)
    // 所以我们开始遍历的时候是直接从第二个元素(索引值为1这个元素开始考察的)
    for(int i = 1; i < n; i++)
    {
        // 性能优化改进
        T e = arr[i];   // 将待排序的值先拷贝一份出来
        
        // 然后把对于j的声明放在外面来，因为在最后那次赋值的时候是需要j的
        // j实际上就是用来保存元素e应该插入的位置
        int j;
        
        // 所以在初始化的时候j = i, 也就是说元素e是不是应该放在j所在的位置。怎么看呢？
        // 首先j要大于0，其次我们要看j前一个元素是否大于待排序元素e，
        // 如果j前一个元素还要比e大，就说明我们当前j这个位置不是e应该存在的位置
        // 所以我们的循环要继续
        for(j = i; j > 0 && arr[j-1] > e; j--)
        {
            // 在循环体里面要做的事情就是把 arr[j]这位置的元素赋值成arr[j-1]这个位置的元素
            // 也就是把前一个位置的元素向后挪一下
            arr[j] = arr[j-1];
        }
        // 在这层for循环结束以后，可以看到，我们j里保存的就是e应该存放的位置
        arr[j] = e;
        
    }
}
```



![](../img/impicture_20220215_200835.png)

可以看到代码改进之后，我们的插入排序性能就明显比选择排序的性能更优了。是因为我们的插入排序不但不再使用交换操作，更重要的是插入排序可以提前终止内层循环。

对于可以提前终止内层循环来说，是插入排序非常重要的一个性质。假设我们有个数组，他本身基本上就是有序的，在这种情况下内层循环它就可以很快的找到它应该插入的位置，此时插入排序的效率会非常的高。

```c++
int *arrTest1 = SortTestHelper::gennerateRandomArray(n, 0, 3);
```

这段测试代码中我们将这10w个数据未0-3之间，那么它必然会存在大量的重复数据（也就是大部分都是有序的数据），这个时候再来进行排序比较

![](../img/impicture_20220215_201431.png)

对于一个近乎有序的数组来说，改进后的插入排序性能提升更为明显，其性能远远的优于选择排序

```c++
int *arrTest1 = SortTestHelper::gennerateNearlyOrderArray(n, 100);  // 近乎有序的数组（100个位置是错误的）
```

![](../img/impicture_20220215_202528.png)

实际上插入排序处理这种近乎有序的数据，对于后续的n log n级别的排序算法来说都还要快。这也就是为什么插入排序是具有实际意义的一种重要排序算法。

在一些极端情况下，比如要排序的数组是一个完全有序的数组，这个时候插入排序将变成一个O(n)级别的排序算法，也就是在内层循环，每一次值判断一次，发现当前的位置就是合适的位置，直接就结束内层循环，进入下一次循环。这是插入排序非常重要的一个性质，也正是这个重要原因，插入排序会在更加复杂的排序算法中作为一个子过程来进行优化。

## 冒泡排序Bubble Sort

说道近乎有序，那么这里就得再提一个排序算法，冒泡排序。

冒泡排序是一种较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。

![preview](../img/v2-e9dd4548c34af801885e5d3190116473_r.jpg)

**我们先分析第1趟排序**

当i=5,j=0时，a[0]<a[1]。此时，不做任何处理！

当i=5,j=1时，a[1]>a[2]。此时，交换a[1]和a[2]的值；交换之后，a[1]=30，a[2]=40。

当i=5,j=2时，a[2]>a[3]。此时，交换a[2]和a[3]的值；交换之后，a[2]=10，a[3]=40。

当i=5,j=3时，a[3]<a[4]。此时，不做任何处理！

当i=5,j=4时，a[4]>a[5]。此时，交换a[4]和a[5]的值；交换之后，a[4]=50，a[3]=60。

于是，第1趟排序完之后，数列{20,40,30,10,60,50}变成了{20,30,10,40,50,60}。此时，数列末尾的值最大。



**根据这种方法：**

第2趟排序完之后，数列中a[5...6]是有序的。

第3趟排序完之后，数列中a[4...6]是有序的。

第4趟排序完之后，数列中a[3...6]是有序的。

第5趟排序完之后，数列中a[1...6]是有序的。

第5趟排序之后，整个数列也就是有序的了。



**☀ 冒泡排序C实现二**

观察上面冒泡排序的流程图，第3趟排序之后，数据已经是有序的了；第4趟和第5趟并没有进行数据交换。

下面我们对冒泡排序进行优化，使它效率更高一些：添加一个标记，如果一趟遍历中发生了交换，则标记为true，否则为false。如果某一趟没有发生交换，说明排序已经完成！

```c++
// 冒泡排序
template<typename T>
void BubbleSort(T arr[], int n)
{
    int newn;   // 使用newn进行优化
    
    do
    {
        newn = 0;
        for(int i = 1; i < n; i++)
        {
            if(arr[i-1] > arr[i])
            {
                swap(arr[i-1], arr[i]);
                
                // 记录最后一次交换的位置，在此之后的元素在下一轮扫描中均不考虑
                newn = i;
            }
        }
        n = newn;
    } while (newn > 0);
}
```



## 希尔排序 Shell Sort

通过插入排序还可以引申出一种非常重要的排序算法 希尔排序 Shell Sort。希尔排序整体思路就是插入排序的一个延伸，在插入排序中我们每一次都和之前的一个元素进行比较，而希尔排序尝试和之前第h个元素进行比较，这样下来，通过将这个h从一个很大的值，逐步缩小到1，一步一步的将一个完全无序的数组，变成一个近乎有序的数组（有序性更强的数组），到最后h等于1的时候最终变成一个排好序的数组，这个过程使得整个算法的时间复杂度发生了一个质变。

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。

希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。

它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。

### 适用说明

希尔排序时间复杂度是 **O(n^(1.3-2))**，空间复杂度为常数阶 **O(1)**。希尔排序没有时间复杂度为 **O(n(logn))** 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 **O(n^2 )** 复杂度的算法快得多。

### 过程图示

希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

在此我们选择增量 **gap=length/2**，缩小增量以 **gap = gap/2** 的方式，用序列 **{n/2,(n/2)/2...1}** 来表示。

如图示例：

（1）初始增量第一趟 **gap = length/2 = 4**

![img](../img/ShellSort-01.png)

（2）第二趟，增量缩小为 2

![img](../img/ShellSort-02.png)

（3）第三趟，增量缩小为 1,得到最终排序结果

![img](../img/ShellSort-03.png)

c++实现

```c++
// 希尔排序
template<typename T>
void ShellSort(T arr[], int n){

    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...
    int h = 1;
    while( h < n/3 )
        h = 3 * h + 1;

    while( h >= 1 ){

        // h-sort the array
        for( int i = h ; i < n ; i ++ ){

            // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序
            T e = arr[i];
            int j;
            for( j = i ; j >= h && e < arr[j-h] ; j -= h )
                arr[j] = arr[j-h];
            arr[j] = e;
        }

        h /= 3;
    }
}
```

希尔排序，最重要的第一步就是分组。怎么分组？我们对这组数据找到一个间隔，然后每隔一定的间隔就将这些元素分到一组。这个间隔在希尔排序中一般是没有硬性要求的，我们一般会取数组元素的一半作为间隔。

分完组后，我下一步要做的就是对组内每一个元素进行排序，组内排序使用插入排序进行。

排好序后，我们对单前的数组再次拿到一个分组间隔，进行数据分组，然后插入排序。注意这个时候，我们的间隔要在原来的基础上减半。

以此类推，知道我们的间隔变成1，那么这个时候，就只有一个分组，这个分组里经过了以上的排序，已经是一个近乎有序的数组，而我们知道，插入排序在处理有序性强的数组性能是很高的。这也就是为什么希尔排序性能高的根本所在。

## 排序算法的性能测试

```c++
// int *arrTest1 = SortTestHelper::gennerateRandomArray(n, 0, n);   // 全无序随机数组
    int *arrTest1 = SortTestHelper::gennerateNearlyOrderArray(n, 100);  // 近乎有序的数组（100个位置是错误的）
    int *arrTest2 = SortTestHelper::copyIntArray(arrTest1, n);
    int *arrTest3 = SortTestHelper::copyIntArray(arrTest1, n);
    int *arrTest4 = SortTestHelper::copyIntArray(arrTest1, n);
    SortTestHelper::testSort("选择排序（Selection sort）", SelectionSort, arrTest1, n);
    SortTestHelper::testSort("插入排序（InsertionSort sort）", InsertionSort, arrTest2, n);
    SortTestHelper::testSort("冒泡排序（BubbleSort sort）", BubbleSort, arrTest3, n);
    SortTestHelper::testSort("希尔排序（Shell sort）", ShellSort, arrTest4, n);
```

测试10w无序数组

![](../img/impicture_20220216_120355.png)

测试10w近乎有序数组

![](../img/impicture_20220216_120547.png)

可以看到冒泡排序在处理无序数组的时候，性能最差，哪怕是有序数组性能也高不到哪。希尔排序无论是乱序还是有序，性能都是最优，插入排序处理有序性强的数据性能较好，选择排序处理无序和有序都是一样的，无差别