# O(n*log n)的排序算法

![](../img/impicture_20220216_144202.png)

## 归并算法Merge Sort

归并排序（Merge sort）是建立在归并操作上的一种有效、稳定的排序算法，该算法是采用分治法(Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

### 适用说明

当有 n 个记录时，需进行 logn 轮归并排序，每一轮归并，其比较次数不超过 n，元素移动次数都是 n，因此，归并排序的时间复杂度为 O(nlogn)。归并排序时需要和待排序记录个数相等的存储空间，所以空间复杂度为 O(n)。

归并排序适用于数据量大，并且对稳定性有要求的场景。

实际上这也是 n*log n这样一个算法的来源，通常就是通过一个二分法，达到一个log n这样一个层级，之后每一个层级用O(n)级别的算法来做事情。

### 过程图示

归并排序是递归算法的一个实例，这个算法中基本的操作是合并两个已排序的数组，取两个输入数组 A 和 B，一个输出数组 C，以及三个计数器 i、j、k，它们初始位置置于对应数组的开始端。

A[i] 和 B[j] 中较小者拷贝到 C 中的下一个位置，相关计数器向前推进一步。

当两个输入数组有一个用完时候，则将另外一个数组中剩余部分拷贝到 C 中。

![img](../img/MergeSort-01.png)

对于归并过程，这里展示一个另外的图辅助理解

![](../img/impicture_20220216_152140.png)

比如有这样一个数组，他的左半部分已经排好序，右半部分也已经排好序，那么应该如何将这两个部分归并成一个排好序的数组呢？

对于归并排序，我们不能像之前的插入排序一样，直接在原数组中通过交换位置来完成排序过程。这里我们开辟一个同样大小的临时空间，来辅助我们完成这个归并过程。有了这个临时空间，我们的归并过程确实变得简单了起来，但是这也是归并算法的一个缺点，它确实可以将算法复杂度降低到 O(n*log n)这个级别，但是它比之前我们提到的插入排序和选择排序等，多使用了存储空间（O(n)的额外的空间）。

那怎么归并呢？这里就需要使用3个索引来对数组进行追踪。蓝色的箭头表示我们最终在归并的过程中要追踪的位置，两个红色的箭头分别指向这两个已经排好序的数组单前我们要考虑的元素。

![](../img/impicture_20220216_155604.png)

比如这里2和1，谁应该放在最终的数组（蓝色箭头指向的那个数组），1比2小，所以1就应该放在蓝色箭头指向的位置，然后蓝色箭头后移，来考虑下一个位置应该放谁，同时原来1所在的那个红色箭头也后移，也就是原来1所在的数组也可以考虑下一个元素了。所以下一步我们就该考虑2 和 4这两个元素了

![](../img/impicture_20220216_155927.png)

然后这里2更小，所以2放入到蓝色箭头指向的位置，原来2的红色箭头后移，判断3和4。

![](../img/impicture_20220216_160054.png)

以此类推...

如何结束归并？当这两半有序数组的箭头指向只要有任意一个指向超出了数组长度（这里数组长度是指着有序的一半的数组长度），那么就把另外一个数组里剩下的元素全都拷贝到剩下的最终数组中就可以。

我们可以看到，在这个算法中我们使用了3个索引位置，对于这3个索引位置，我们必须定义清楚，保证无误，这样才能保证我们在写程序的时候不会出问题

![](../img/impicture_20220216_160718.png)

比如这里，我将下面两个有序数组，指引单前需要考虑的元素位置的索引定义为 i 和 j。将上面这个归并的最终数组中的这个索引叫做 k 。注意这个定义，i和j指向的是当前正在考虑的元素，而k指向的是这两个元素相比较之后，最终应该放到的这个归并数组的位置。要注意，这里k的定义，不表示归并结束后，已经放置的最后一个元素的位置，而表示下一个需要放置的位置。在写程序的时候，我们就需要维护这个i,j ,k的定义，维持我们的这些变量，在算法运行的过程中用于满足我们的定义，是写出一个正确算法的基础。

---

自顶向下的归并排序，递归分组图示：

![img](../img/MergeSort-02.png)

对第三行两个一组的数据进行归并排序

![img](../img/MergeSort-03.png)

对第二行四个一组的数据进行归并排序

![img](../img/MergeSort-05.png)

整体进行归并排序

![img](../img/MergeSort-04.png)

### 归并排序c++实现

```c++
// 将arr[l..mid]和arr[mid...r]这两部分进行归并
template<typename T>
void __merge(T arr[], int l, int mid, int r)
{
    // 对于这个归并。我们首先需要开辟一个临时的空间
    // 这个空间需要多大呢？
    // 需要r-l+1,是因为我们这里l和r都是闭空间，所以需要+1
    // 其实很好理解，比如l=0, r=3; [0, 3]是一个4个元素的数组大小，3-0+1 = 4
    T aux[r-l+1];
    
    // 将我们要处理的这个arr数组中的元素全都复制到我们的辅助数组aux中
    for(int i = l; i<= r; i++)
    {
        // 在具体赋值的时候，要注意，我们的aux这个空间是从0开始的，
        // 但是我们的这arr这个空间是从l开始的，他们之间有一个l的偏移量
        // 所以我们赋值的时候应该是将arr的第i个元素赋值给aux的第i-l个元素
        aux[i-l] = arr[i];
    }
    
    // 设置两个索引指向这两个已经排好序的这两个子数组（左右两边）
    int i = l, j = mid+1;
    
    // 使用一个新的索引k来进行遍历，来决定arr[k]的位置究竟应该是谁
    for(int k = l; k <= r; k++)
    {
        // i,j数组越界情况考虑
        // 我们能访问i-l和j-l的前提是i和j这两个索引还在这两个数组相应的位置里面（i还在左边数组里，j还在右边数组里）
        
        // 但是很有可能我们算法运行到一定的时候，对于i这个索引来说，它已经超出了它的范围，也就是i已经大于mid
        // 在这种情况如果我们的k还没有遍历完，就说明j索引所指的这数组中的元素（右边这个数组中的元素）
        // 还没有归并完全，这个时候我们的arr[k]就应该取的是aux[j-l]相应的位置的元素值
        if(i>mid)
        {
            // 其实说白了就是左边归并完了，右边还有值没归并，那么就直接将右边的值挨个放入arr[k]中
            arr[k] = aux[j-l];
            j++;
        }
        else if(j>r)
        {
            // 同样对于j越界，也是一样的，右边归并完了，但是左边还有值没有归并完，那就直接将左边挨个放入arr[k]中
            arr[k] = aux[i-l];
            i++;
        }
        // 如果这两个条件都不满足，才说明这个时候i和j都是有效的，这个时候才进行左右比对归并
        // 所以要先判断索引的合法性，才能放心的比较两个索引的值
        
        // 注意这里，也是同样的，因为有aux和arr之间有一个l的偏移，所以不能直接用aux[i]和aux[j]进行比较
        // 而是应该减去这个偏移
        else if(aux[i-l] < aux[j-l])
        {
            // 如果小于，那么显然arr[k]这个位置应该存放的就是aux[i-l]相应的这个元素
            arr[k] = aux[i-l];
            // 随后i往后走一个位置
            i++;
        }
        else
        {
            // 否者的话，arr[k]这个位置就应该存放aux[j-l]
            arr[k] = aux[j-l];
            // 同样j++
            j++;
        }
    }
}

// 递归使用归并排序，对arr[l, ...r]的范围进行排序
template<typename T>
void __mergeSort(T arr[], int l, int r)
{
    // 对于一个递归函数来说，我们首先要处理的就是递归到底的情况。
    // 很容易想到，当l<r的时候，我们要处理的这部分，就至少由两个元素，左边一个，右边一个
    // 这个时候我们还是需要进行一次排序
    // 但是当l>=r的时候，就表示我们只有一个元素，甚至一个元素都没有，l>r是不可能发生的情况
    // （也就是代表我们当前要处理的数据集为空）
    if(l>=r)
    {
        return;
    }
    
    // 否者的话我们就进行一次归并排序
    // 首先计算这个区间他的中点位置在哪？
    int mid = (l+r)/2;  
    // 注意这里有个隐含的潜在bug，就是当这个数据集非常大的时候（l和r都是非常大的int），这里l+r很可能会溢出int类型
    
    // 下面就可以对分开的左右两个部分分别进行归并排序
    __mergeSort(arr, l, mid);
    __mergeSort(arr, mid+1, r);
    
    // 这两部分都归并排序好之后，就要使用merge将归并排序好的这两个部分
    // 从l-mid,在从mid-r这两部分进行一个merge操作
    __merge(arr, l, mid, r);
    
    // 这次merge完成之后我们就完成了整个归并排序的过程
}

template<typename T>
void megeSort(T arr[], int n)
{
    // 在具体的实现中，归并排序的本质是一次递归的排序的过程，
    // 在这个过程中我们需要依次的对这个数组的不同部分继续进行一个归并排序
    // 为此我们这里会作为一个子函数。
    
    // 他的参数就是我们传递进来的这个数组以及单前要处理的数组的起始位置，以及结束位置
    __mergeSort(arr, 0, n-1);
    
    // 注意，因为我们这个数组范围区间定义是一个前闭后闭的区间，也就是__mergeSort这个函数
    // 中，参数r的定义，这里我们定义为最后一个元素的位置，而不是最后一个元素后一个的位置。
    // 为此，我们这里掉用的就是n-1
    // 这个定义非常重要，在写算法的，这些细微的边界问题，很有可能会直接决定我们算法的准确信
}
```

测试归并排序和插入排序的性能比较

```c++
	int n = 50000;
    std::cout << "测试随机数组排序，数组大小 = " << n << ", 随机范围 [0, " << n << "]" << std::endl;

    int* arr1 = SortTestHelper::gennerateRandomArray(n, 0, n);
    int* arr2 = SortTestHelper::copyIntArray(arr1, n);
    
    SortTestHelper::testSort("插入排序（Insertion Sort） ", InsertionSort, arr1, n);
    SortTestHelper::testSort("归并排序（Merge Sort） ", megeSort, arr2, n);
    
    delete[] arr1;
    delete[] arr2;
```

![](../img/impicture_20220217_140646.png)

测试近乎有序的数组排序

```c++
	int swapTime = 10;
    
    std::cout << "测试近乎有序的数组排序，数组大小 = " << n << ", 乱序数: " << swapTime << std::endl;

    int* arr3 = SortTestHelper::gennerateNearlyOrderArray(n, swapTime);
    int* arr4 = SortTestHelper::copyIntArray(arr3, n);
    
    SortTestHelper::testSort("插入排序（Insertion Sort） ", InsertionSort, arr3, n);
    SortTestHelper::testSort("归并排序（Merge Sort） ", megeSort, arr4, n);
    // 测试近乎有序��数组排序，数组大小 = 50000, 乱序数: 10
    // 插入排序（Insertion Sort）  : 0.001073 s 
    // 归并排序（Merge Sort）  : 0.005798 s
```

![](../img/impicture_20220217_141640.png)

### 归并排序算法优化

#### 优化1

以上我们基本实现了归并排序算法，接下来我将对归并排序算法进行优化。

首先我们从上面的测试比较中看出来，在处理近乎有序的数组排序的时候，归并排序的性能并没有插入排序快。

那归并排序有没有可能对这种极端的情况（有序数组进行排序）进行优化呢？是可以的。

先看这部分代码

```c++
template<typename T>
void __mergeSort(T arr[], int l, int r)
{
    if(l>=r)
    {
        return;
    }
    int mid = (l+r)/2;  
    // 下面就可以对分开的左右两个部分分别进行归并排序
    __mergeSort(arr, l, mid);
    __mergeSort(arr, mid+1, r);
    
    // 注意看这里
    
    __merge(arr, l, mid, r);
    
    // 这次merge完成之后我们就完成了整个归并排序的过程
}
```

在我们对数组的左右两边进行递归的归并排序之后，不管三七二十一，直接下一句操作就是将这左右两边的数组进行merge合并操作。但是这个时候其实如果左边的最大值小于等于右边的最小值（也就是 arr[mid] <= arr[mid+1]），那么就说明这个arr数组已经是有序的了。就不再需要进行merge操作了。

改进后的代码

```c++
template<typename T>
void __mergeSort(T arr[], int l, int r)
{
    if(l>=r)
    {
        return;
    }

    int mid = (l+r)/2;  

    __mergeSort(arr, l, mid);
    __mergeSort(arr, mid+1, r);

    // 代码优化：
    // 在我们对数组的左右两边进行递归的归并排序之后，不管三七二十一，
    // 直接下一句操作就是将这左右两边的数组进行merge合并操作。
    // 但是这个时候其实如果左边的最大值小于等于右边的最小值（也就是 arr[mid] <= arr[mid+1]），
    // 那么就说明这个arr数组已经是有序的了。就不再需要进行merge操作了。
    
    if(arr[mid] > arr[mid+1])
    {
        __merge(arr, l, mid, r);
    }
}
```

改进后代码测试

![](../img/impicture_20220217_142657.png)

可以很直观的看到，这样一个小小的改进，直接将有序性强的数组归并排序的性能提升到和插入排序近乎相等。虽然归并排序还是会比插入排序慢一些，这是因为归并排序无法退化成一个O(n)的算法。它还是需要对log(n)这么多层进行递归，只不过每次递归的过程马上就会发现不需要进行merge计算。这样一来我们的归并排序算法在近乎于有序的数组中，时间效率也是可以令人满意的。

注意这里多了一层if语句判断，在有序数组中会有很大的性能提升，但是在有些情况下，比如完全无序的数组，这个多出来的if语句也许会成为性能障碍，因为if语句判断本身也是需要耗费性能的。但是总体影响不大。所以如果处理的数据会有出现近乎有序的情况，那么还是建议加上这层if优化。

#### 优化2（对于小数组使用插入排序法进行优化）

以上是归并算法的第一个优化，除此之外，对于近乎所有的高级排序算法，都存在一种优化情况，那就在于递归到底的情况。现在我们的递归情况是递归到只有在一个元素的时候返回回去，但是在元素量非常小的时候，我们可以转而使用插入排序来提高排序性能。这是基于两个原因，一方面当我们的元素数据非常小的时候，整个数组近乎有序的概率就会比较大，此时插入排序有优势。另外一方面，虽然插入排序最差的时间复杂度是O(n^2)级别的，归并排序是O(n log n)级别的，但是我们要知道，对n^2也好，n log n也好，前面是有一个常数系数的，对于这个系数而言，插入排序是要比归并排序小的，换句话说，当n小到一定程度的时候，插入排序是要比归并排序快的。

为此对于我们的递归终止代码，我们就可以进行这样的修改

```c++
	// 这里 r-1 = 15就表示有16个元素及其以下的时候使用插入排序
    if(r-l <= 15)
    {
        InsertionSort(arr, l, r);
        return;
    }
```

![](../img/impicture_20220217_150021.png)

从测试结果上看，这里虽然不是指数级的优化，但是整体上还是对我们的归并算法起到了一定的优化作用

### 自底向上的归并排序

之前我们实现的归并排序算法是自顶向下的归并排序。但是在理解了归并排序之后，我们也完全可以实现自底向上的归并排序。

比如我们现在有这么一个数组，那么我们就可以从左到右依次将这个数组划分为两个两个的小段，然后来进行归并排序的过程。

![](../img/impicture_20220217_150940.png)

在归并排序完成之后，我们再4个元素一个小段的来进行划分，然后继续进行归并排序

![](../img/impicture_20220217_151056.png)

最后8个元素进行排序结束

![](../img/impicture_20220217_151144.png)

在这样一个实现中，我们并不需要递归，只需要迭代就可以完成归并排序了。

```c++
// 将arr[l..mid]和arr[mid...r]这两部分进行归并
template<typename T>
void __merge(T arr[], int l, int mid, int r)
{
    // 对于这个归并。我们首先需要开辟一个临时的空间
    // 这个空间需要多大呢？
    // 需要r-l+1,是因为我们这里l和r都是闭空间，所以需要+1
    // 其实很好理解，比如l=0, r=3; [0, 3]是一个4个元素的数组大小，3-0+1 = 4
    T aux[r-l+1];
    
    // 将我们要处理的这个arr数组中的元素全都复制到我们的辅助数组aux中
    for(int i = l; i<= r; i++)
    {
        // 在具体赋值的时候，要注意，我们的aux这个空间是从0开始的，
        // 但是我们的这arr这个空间是从l开始的，他们之间有一个l的偏移量
        // 所以我们赋值的时候应该是将arr的第i个元素赋值给aux的第i-l个元素
        aux[i-l] = arr[i];
    }
    
    // 设置两个索引指向这两个已经排好序的这两个子数组（左右两边）
    int i = l, j = mid+1;
    
    // 使用一个新的索引k来进行遍历，来决定arr[k]的位置究竟应该是谁
    for(int k = l; k <= r; k++)
    {
        // i,j数组越界情况考虑
        // 我们能访问i-l和j-l的前提是i和j这两个索引还在这两个数组相应的位置里面（i还在左边数组里，j还在右边数组里）
        
        // 但是很有可能我们算法运行到一定的时候，对于i这个索引来说，它已经超出了它的范围，也就是i已经大于mid
        // 在这种情况如果我们的k还没有遍历完，就说明j索引所指的这数组中的元素（右边这个数组中的元素）
        // 还没有归并完全，这个时候我们的arr[k]就应该取的是aux[j-l]相应的位置的元素值
        if(i>mid)
        {
            // 其实说白了就是左边归并完了，右边还有值没归并，那么就直接将右边的值挨个放入arr[k]中
            arr[k] = aux[j-l];
            j++;
        }
        else if(j>r)
        {
            // 同样对于j越界，也是一样的，右边归并完了，但是左边还有值没有归并完，那就直接将左边挨个放入arr[k]中
            arr[k] = aux[i-l];
            i++;
        }
        // 如果这两个条件都不满足，才说明这个时候i和j都是有效的，这个时候才进行左右比对归并
        // 所以要先判断索引的合法性，才能放心的比较两个索引的值
        
        // 注意这里，也是同样的，因为有aux和arr之间有一个l的偏移，所以不能直接用aux[i]和aux[j]进行比较
        // 而是应该减去这个偏移
        else if(aux[i-l] < aux[j-l])
        {
            // 如果小于，那么显然arr[k]这个位置应该存放的就是aux[i-l]相应的这个元素
            arr[k] = aux[i-l];
            // 随后i往后走一个位置
            i++;
        }
        else
        {
            // 否者的话，arr[k]这个位置就应该存放aux[j-l]
            arr[k] = aux[j-l];
            // 同样j++
            j++;
        }
    }
}

// 以下是自底向上的归并排序实现

template<typename T>
void mergeSortBU(T arr[], int n)
{
    // 首先需要一轮循环，这轮循环是对进行merge的元素个数进行遍历
    // 这里归并排序每次开始只看一个元素，然后2个，然后4个，然后8个，每次翻一倍
    for(int sz = 1; sz <= n; sz*=2)
    {
        // 下面我们的第二轮循环，就是具体每一轮在归并的过程中，起始的元素位置
        // 这个位置我们从0开始，每次i位置的平移应该是2个sz这个位置
        // 也就是说，在第一轮我们将对从 [0, sz-1], [sz, 2sz-1]这两部分进行一次归并
        // 第二轮我们将对 [2sz, 3sz-1],[3sz, 4sz-1]这两部分进行一次归并
        // ...
        for(int i = 0; i + sz < n; i+=sz+sz)
        {
            // 数组边界问题处理
            // 首先对于归并过程来说，我们要对至少两个部分进行归并，否者整个归并是没有意义的
            // 因为我们的归并过程就是要将两个已经有序的数组给合并成一个有序数组
            
            // 上面for里的 i + sz < n; 保证了i+sz-1不会再数组arr里越界
            
            // 另外在数组的末尾的部分，有可能不足size那么多个元素，换句话说 i+2*sz-1 这个有可能会越界
            // 为此我们去 i+2*sz-1 和 n-1他们之间的最小值，也就是说，当i+2*sz-1比n-1还要大（数组越界）的时候
            // 我们就取n-1
            // 可以想象，我们这个mege函数在遍历到数组靠近后面的时候，第二部分可能不足size那么大小
            // 但是没有关系，我们之前实现的__mege函数在这种情况下依旧能够正常运行
            
            // 对arr[i, i+sz-1]和arr[i+sz, i+2sz-1]这两部分进行归并
            __merge(arr, i, i+sz-1, min(i+2*sz-1, n-1));
            
        }
    }
}
```



##### 性能测试

![](../img/impicture_20220217_150021.png)

可以看到，这种自底向上的归并排序，性能上虽然和之前使用递归实现的归并差不多，但是较真来说，其实自底向上这种性能并没有之前的递归实现的自顶向下的归并性能好。

自底向上的这种归并排序，它有一个很重要的作用，如果我们注意看这个代码就会发现，这个排序过程中，没有使用数组的一个非常重要的特性，就是通过索引直接获取元素，也正因为如此，这样一个自底向上的一个归并排序算法排序，可以非常好的使用nlogn的时间对链表进行排序。

---

## 快速排序Quick Sort

我们知道，归并排序是不管数组的内容是什么，直接将整个数组一分为二之后进行排序归并。而快速排序则是每次从当前考虑的数组中选择一个元素，以这个元素为基点。

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_172414.png)

比如在我这个数组中选择4为基点。之后想办法把4这个元素挪到它在排好序之后应该存在的位置。

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_172548.png)

4存在这个位置就使得整个数组有了一个性质，那就是4之前的元素都是小于4的，4之后的元素都是大于4的。之后我们要做的事情就是对小于4的这部分子数组和对大于4的这部分子数组分别继续使用快速排序的思想进行排序。逐步递归下去完成整个排序过程。

所以可以看到，对于快速排序算法来说，如果把选定的元素放在它正确的位置就显得很重要。而这个过程也正是快速排序的核心。通常我们管这个子过程叫 Partition ，也就是把整个数组分成两个部分。在这个过程中，我们一般都是将整个数组的第一个元素作为分界的标志点。对于这个数组，我管他叫做 l ,也就是left。

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_173507.png)

之后我们逐步遍历右边所有没有被访问过的元素。在遍历的过程中，我们将逐渐的整理整个数组，一部分是小于v这个元素的，一部分是大于v这个元素的。当然，在这个过程中我们就需要记录哪里是大于v和小于v的分界点，这里就使用 j 来记录这个位置。单前访问的元素管他叫做 i 。这样一来，我们整个数组从[l+1, j] 前闭后闭这整个区间的元素就都是小于v的。而从[j+1, i-1]这个闭区间的元素都是大于v的。

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_173659.png)

接下来我们讨论 i 这个位置如何来决定单前的元素，到底要怎样变化才能使得我们整个数组继续保持这样的一个性质。

我们分两种情况来讨论，如果单前的这个元素e，他是比v还要大的，那么这种情况非常简单，他就直接放在大于v这一部分的后面 。此时这数组就变成了这个样子。然后我们马上去讨论下一个元素，也就是i++

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_175132.png)

但是如果我们当前讨论的这个元素e，它是必v要小的，那么这里就会稍微麻烦点，我们要把当前这个元素e放到小于v，也就是橙色这部分。这里我们只需要把当前橙色部分，也就是j所指的元素 和 蓝色部分也就是当前考察的元素e也就是i这个位置，这两个位置的元素进行一下交换，

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_175547.png)

可以看到有一个大于v的元素放到了现在i所在的位置，而我们单前所考察的这个小于v的元素被放到了j的后面。

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_175757.png)

这种情况下我们的j就需要++。也就相当于我们的橙色部分的元素多了一个。经过这样的改变之后，我们在进行i++,继续考察下一个元素

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_180044.png)

可以想象，在使用这个方式对我们的数组进行遍历，遍历完之后，就变成了这个样子。我们整个数组被分为了3个部分，第一个元素是v，然后橙色部分是小于v，紫色部分是大于v

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_180151.png)

最后我们要做的事情就是将 l 这个位置和 j 这个位置进行一下交换。可以看到此时我们的数组就被分为了我们设想的那样，被分为了小于v和大于v的两个部分。而v这个元素就被放在了它应该在的位置，而此时指向v的索引就是 j  .

![](D:\study\c++\算法与数据结构\Algorithms-and-Data-Structures\img\impicture_20220217_180501.png)

有了这个基础我们就能写出我们的第一版的快速排序。