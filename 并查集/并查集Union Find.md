# 并查集Union Find

### 概念及其介绍

并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。

并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。

### 适用说明

并查集用在一些有 **N** 个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这个过程看似并不复杂，但数据量极大，若用其他的数据结构来描述的话，往往在空间上过大，计算机无法承受，也无法在短时间内计算出结果，所以只能用并查集来处理。

### 连接问题 Connectivity Problem

并查集可以非常高效的回答一类称之为连接问题的问题。

![](../img/impicture_20220225_164902.png)

首先我们来可视化的看这么一个问题，在这个图上有若干个点，点与点之间他们有可能相连，如果在图中任意指定两个点，问这两个点之间是否是相连的？相信人眼只是通过看这个图，一些点是否相连是很难看出来的，在这种时候就需要使用计算机，可是计算机如何高效的回答这个问题呢？答案就是使用并查集这种数据结构。

连接问题在实际生活中有着非常重要的作用，它最重要的一个作用就是可以判断网络中节点间的连接状态。这里这个网络不是具体指现实生活中的上网浏览的网络，而是泛指一个抽象的概念，指代用户之间形成的网络。比如好友关系网络，人际关系网络。一个大型数据库中，有很多的电影，书籍，音乐等等，这些多媒体之间也能形成网络。

并查集还有另外一个很重要的作用，就是可以实现数学中的集合类。并查集这个并，就是实现一个并集的意思，如果我们使用数学的集合的思路，来解决问题，经常使用并集这样的操作，同时需要查询元素在集合中的状态的话，并查集也是一个非常好的选择。

## 并查集

首先我们来看并查集支持什么样的操作。对于一组数据来说，并查集主要支持两个操作：(这两个操作也就是并查集名字的由来)

> union(p, q);		将p和q两个元素合并在一起，也就是所谓的连接起来。

> find(p);		也就是查的意思。我们利用find来查p这个元素是在哪个组中。

有了上面这两个操作，也就能轻易的回答这样一个问题：

> isConnected(p, q);	传入p，q这两个元素，来看p， q是否是连接的。

![](../img/impicture_20220225_195734.png)

对于这样的一个需求，我们最简单的一个数据表示方式就是使用一个数组就好了。数组的索引用来表示元素，0-9一共表示10个元素，那么我们怎么来表示这些元素之间的连接关系呢？我们可以给每一个元素附上一个值，如上图 **0-4** 下面都是 **0**，**5-9** 下面都是 **1**，表示 **0、1、2、3、4** 这五个元素是相连接的，**5、6、7、8、9** 这五个元素是相连的

![](../img/impicture_20220225_195905.png)

使用这种方式再举个例子，再如上图 **0、2、4、6、8** 下面都是 **0** 这个集合，表示 **0、2、4、6、8** 这五个元素是相连接的，**1、3、5、7、9** 下面都是 **1** 这个集合，表示 **0，1、3、5、7、9** 这五个元素是相连的。

![](../img/impicture_20220225_202448.png)

在这样的一个表示下，我们如何找到每一个元素它所属的这个组别的id号呢？对于每一个id来讲，我们直接访问它对应的这个id值就好了。也正因为如此，这样的一个实现，也被叫做Quick Find，也就是实现Find这个操作是非常快的（直接数组索引拿值），只需要使用O(1)的时间复杂度就够了。

![](../img/impicture_20220225_202407.png)

quickFind这种情况下，实现find操作很容易，但是我们要如何实现Union这个操作呢？比如现在我们想把元素1，和元素2并在一起，那么接下来我们要做的事情就是遍历一遍id，使得元素1对应的id是1，元素2对应的id是0，这个时候，我们要么把数组中所有id为1的元素的id都改为0，要么把所有id为0的元素的id都改为1。这样一来，这两个元素才真正的并在一起。在我们这个例子中，我们任意选择一个奇数或者任意选择一个偶数，把他们连在一起，那么所有的元素也就跟着联在了一起，他们的id号就变成一样的了。通过这个例子，我们也能感受到，我们的union(并)这个操作，他的时间复杂度是O(n)级别的。

```c++
class UnionFind
{

private:
  int* id;    // 对于这个并查集，它用于表示数据的方式，是使用一个数组
  int count;  // 当前这个UnionFind有多少个元素

public:
  // 该构造函数需要用户传入一个n，表示单前这个并查集有多少元素
  UnionFind(int n)
  {
    count = n;
    id = new int[n];

    // 在初始情况下，每一个元素都是自己一个独立的组
    // 所以这里初始化的时候，让id的每一个元素都等于i，换句话说，没有任何两个值他们的id是相同的，也就是初始的时候没有任何两个元素连接在一起
    for(int i = 0; i<n; i++)
      {
        id[i] = i;
      }
  }

  ~UnionFind()
  {
    delete[] id;
  }

public:
  int find(int p)
  {
    assert(p>=0 && p<count);
    return id[p];
  }

  bool isConnected(int p, int q)
  {
    return find(p) == find(q);
  }

  void unionElements(int p, int q)
  {
    assert(p >= 0 && p < count);
    assert(q >= 0 && q < count);
    // 首先用find（o）来找到p相对应的id，用find（q）来找到q的id
    int pID = find(p);
    int qID = find(q);
    if(pID==qID)
    {
      // 说明这两个元素已经是相连的了
      return;
    }

      // 这里我们从头到尾扫描了一遍整个数组，所以他的时间复杂度是O(n)级别的
    for(int i = 0; i < count; i++)
      {
        if(id[i] == pID)
        {
          id[i] = qID;
        }
      }
    
  }


};
```

然后测试现在实现的这个版本的并查集操作10000个元素的速率。（因为这里测试用例是做了并和查这两个操作，所以测试结果答应20000ops。

![](../img/impicture_20220225_205419.png)