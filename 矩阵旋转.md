# 矩阵旋转算法详解

## 一、矩阵旋转的基本类型

### 1. **顺时针旋转90度**
```
原始矩阵：
1 2 3
4 5 6
7 8 9

顺时针旋转90度：
7 4 1
8 5 2
9 6 3
```

### 2. **逆时针旋转90度**
```
原始矩阵：
1 2 3
4 5 6
7 8 9

逆时针旋转90度：
3 6 9
2 5 8
1 4 7
```

### 3. **旋转180度**
```
原始矩阵：
1 2 3
4 5 6
7 8 9

旋转180度：
9 8 7
6 5 4
3 2 1
```

## 二、LeetCode 48. 旋转图像（顺时针旋转90度）

### 问题描述
给定一个 `n × n` 的二维矩阵表示一个图像，将图像**顺时针旋转90度**。

**要求**：原地旋转，即直接修改输入的矩阵，不要使用额外的矩阵。

**示例**：
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

### 解法1：转置 + 反转（最常用）
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 1. 转置矩阵（行列交换）
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        
        // 2. 反转每一行
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

### 解法2：分层旋转（原地操作）
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 分层旋转，从外层到内层
        for (int layer = 0; layer < n / 2; layer++) {
            int first = layer;
            int last = n - 1 - layer;
            
            for (int i = first; i < last; i++) {
                int offset = i - first;
                
                // 保存上边
                int temp = matrix[first][i];
                
                // 左边 -> 上边
                matrix[first][i] = matrix[last - offset][first];
                
                // 下边 -> 左边
                matrix[last - offset][first] = matrix[last][last - offset];
                
                // 右边 -> 下边
                matrix[last][last - offset] = matrix[i][last];
                
                // 上边 -> 右边
                matrix[i][last] = temp;
            }
        }
    }
};
```

### 解法3：四元素交换（更直观）
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 对于每个位置的元素，找到旋转后对应的4个位置
        for (int i = 0; i < (n + 1) / 2; i++) {
            for (int j = 0; j < n / 2; j++) {
                // 获取当前位置的4个对应位置的元素
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = temp;
            }
        }
    }
};
```

## 三、通用旋转函数（支持各种角度）

### 1. **通用矩阵旋转类**
```cpp
class MatrixRotator {
public:
    // 顺时针旋转90度
    static void rotateClockwise(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if (n == 0) return;
        
        // 转置 + 反转每行
        transpose(matrix);
        reverseRows(matrix);
    }
    
    // 逆时针旋转90度
    static void rotateCounterClockwise(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if (n == 0) return;
        
        // 转置 + 反转每列
        transpose(matrix);
        reverseColumns(matrix);
    }
    
    // 旋转180度
    static void rotate180(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if (n == 0) return;
        
        // 反转每行 + 反转每列
        reverseRows(matrix);
        reverseColumns(matrix);
    }
    
    // 旋转任意角度（90度的倍数）
    static void rotate(vector<vector<int>>& matrix, int degrees) {
        degrees = degrees % 360;
        if (degrees < 0) degrees += 360;
        
        switch (degrees) {
            case 90:
                rotateClockwise(matrix);
                break;
            case 180:
                rotate180(matrix);
                break;
            case 270:
                rotateCounterClockwise(matrix);
                break;
            case 0:
                // 不旋转
                break;
            default:
                throw invalid_argument("只能旋转90度的倍数");
        }
    }
    
private:
    // 转置矩阵
    static void transpose(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
    
    // 反转每一行
    static void reverseRows(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
    
    // 反转每一列
    static void reverseColumns(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < n; j++) {
                swap(matrix[i][j], matrix[n - 1 - i][j]);
            }
        }
    }
};
```

### 2. **使用示例**
```cpp
#include <iostream>
#include <vector>

using namespace std;

void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int num : row) {
            cout << num << " ";
        }
        cout << endl;
    }
    cout << endl;
}

int main() {
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    cout << "原始矩阵：" << endl;
    printMatrix(matrix);
    
    // 测试各种旋转
    vector<vector<int>> matrix1 = matrix;
    MatrixRotator::rotateClockwise(matrix1);
    cout << "顺时针旋转90度：" << endl;
    printMatrix(matrix1);
    
    vector<vector<int>> matrix2 = matrix;
    MatrixRotator::rotateCounterClockwise(matrix2);
    cout << "逆时针旋转90度：" << endl;
    printMatrix(matrix2);
    
    vector<vector<int>> matrix3 = matrix;
    MatrixRotator::rotate180(matrix3);
    cout << "旋转180度：" << endl;
    printMatrix(matrix3);
    
    vector<vector<int>> matrix4 = matrix;
    MatrixRotator::rotate(matrix4, 270);  // 逆时针90度
    cout << "旋转270度（逆时针90度）：" << endl;
    printMatrix(matrix4);
    
    return 0;
}
```

## 四、矩形矩阵（非正方形）的旋转

### 1. **旋转矩形矩阵（需要创建新矩阵）**
```cpp
class RectMatrixRotator {
public:
    // 顺时针旋转90度（矩形矩阵）
    static vector<vector<int>> rotateClockwise(const vector<vector<int>>& matrix) {
        if (matrix.empty()) return {};
        
        int m = matrix.size();      // 原矩阵行数
        int n = matrix[0].size();   // 原矩阵列数
        
        // 旋转后：行数 = 原列数，列数 = 原行数
        vector<vector<int>> rotated(n, vector<int>(m));
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 旋转后位置：行 = j，列 = m-1-i
                rotated[j][m - 1 - i] = matrix[i][j];
            }
        }
        
        return rotated;
    }
    
    // 逆时针旋转90度（矩形矩阵）
    static vector<vector<int>> rotateCounterClockwise(const vector<vector<int>>& matrix) {
        if (matrix.empty()) return {};
        
        int m = matrix.size();      // 原矩阵行数
        int n = matrix[0].size();   // 原矩阵列数
        
        // 旋转后：行数 = 原列数，列数 = 原行数
        vector<vector<int>> rotated(n, vector<int>(m));
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 旋转后位置：行 = n-1-j，列 = i
                rotated[n - 1 - j][i] = matrix[i][j];
            }
        }
        
        return rotated;
    }
    
    // 旋转180度（矩形矩阵）
    static vector<vector<int>> rotate180(const vector<vector<int>>& matrix) {
        if (matrix.empty()) return {};
        
        int m = matrix.size();      // 原矩阵行数
        int n = matrix[0].size();   // 原矩阵列数
        
        vector<vector<int>> rotated(m, vector<int>(n));
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 旋转后位置：行 = m-1-i，列 = n-1-j
                rotated[m - 1 - i][n - 1 - j] = matrix[i][j];
            }
        }
        
        return rotated;
    }
};
```

### 2. **原地旋转矩形矩阵（如果可能）**
```cpp
// 对于矩形矩阵，原地旋转通常需要更复杂的算法
// 这里提供一种基于环状旋转的方法

class RectMatrixRotatorInPlace {
public:
    // 顺时针旋转90度（原地，但需要一些额外空间）
    static void rotateClockwise(vector<vector<int>>& matrix) {
        if (matrix.empty()) return;
        
        int m = matrix.size();
        int n = matrix[0].size();
        
        // 如果矩阵不是正方形，我们需要创建一个新矩阵
        // 但这里我们尝试原地旋转（对于某些情况）
        
        // 方法：先转置，然后调整行列
        // 注意：这不是真正的原地，因为转置后行列数变化
        
        // 更通用的方法：使用环状旋转
        vector<vector<int>> rotated(n, vector<int>(m));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rotated[j][m - 1 - i] = matrix[i][j];
            }
        }
        
        // 如果希望修改原矩阵，需要调整大小
        matrix.resize(n);
        for (int i = 0; i < n; i++) {
            matrix[i].resize(m);
            for (int j = 0; j < m; j++) {
                matrix[i][j] = rotated[i][j];
            }
        }
    }
};
```

## 五、旋转的数学原理

### 1. **坐标变换公式**
```cpp
/*
旋转的数学原理：
对于点 (x, y) 绕原点旋转 θ 角度：
x' = x * cosθ - y * sinθ
y' = x * sinθ + y * cosθ

对于矩阵旋转（图像处理中）：
我们通常以矩阵中心为旋转中心
*/

class MatrixRotationMath {
public:
    // 计算旋转后的坐标（以矩阵中心为原点）
    static pair<int, int> rotatePoint(int x, int y, int n, double angle) {
        // 将坐标平移到以中心为原点
        double cx = x - (n - 1) / 2.0;
        double cy = y - (n - 1) / 2.0;
        
        // 转换为弧度
        double rad = angle * M_PI / 180.0;
        
        // 旋转
        double new_x = cx * cos(rad) - cy * sin(rad);
        double new_y = cx * sin(rad) + cy * cos(rad);
        
        // 平移回原坐标系
        int result_x = round(new_x + (n - 1) / 2.0);
        int result_y = round(new_y + (n - 1) / 2.0);
        
        return {result_x, result_y};
    }
    
    // 使用数学公式旋转矩阵（支持任意角度，但需要插值）
    static vector<vector<int>> rotateArbitrary(const vector<vector<int>>& matrix, double angle) {
        int n = matrix.size();
        if (n == 0) return {};
        
        vector<vector<int>> result(n, vector<int>(n, 0));
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                auto [new_i, new_j] = rotatePoint(i, j, n, angle);
                
                // 检查新坐标是否在边界内
                if (new_i >= 0 && new_i < n && new_j >= 0 && new_j < n) {
                    result[new_i][new_j] = matrix[i][j];
                }
            }
        }
        
        return result;
    }
};
```

## 六、相关算法题

### 1. **搜索旋转排序数组**
```cpp
// LeetCode 33. 搜索旋转排序数组
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            }
            
            // 判断哪一部分是有序的
            if (nums[left] <= nums[mid]) {  // 左半部分有序
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;  // 在左半部分
                } else {
                    left = mid + 1;   // 在右半部分
                }
            } else {  // 右半部分有序
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;   // 在右半部分
                } else {
                    right = mid - 1;  // 在左半部分
                }
            }
        }
        
        return -1;
    }
};
```

### 2. **旋转数组**
```cpp
// LeetCode 189. 旋转数组
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;  // 处理k大于n的情况
        
        // 方法1：三次反转
        reverse(nums.begin(), nums.end());      // 反转整个数组
        reverse(nums.begin(), nums.begin() + k); // 反转前k个
        reverse(nums.begin() + k, nums.end());   // 反转剩余部分
        
        // 方法2：使用额外数组
        /*
        vector<int> temp(n);
        for (int i = 0; i < n; i++) {
            temp[(i + k) % n] = nums[i];
        }
        nums = temp;
        */
    }
};
```

### 3. **旋转链表**
```cpp
// LeetCode 61. 旋转链表
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (!head || !head->next || k == 0) return head;
        
        // 计算链表长度
        int length = 1;
        ListNode* tail = head;
        while (tail->next) {
            tail = tail->next;
            length++;
        }
        
        // 实际需要旋转的次数
        k %= length;
        if (k == 0) return head;
        
        // 找到新的尾节点
        ListNode* newTail = head;
        for (int i = 0; i < length - k - 1; i++) {
            newTail = newTail->next;
        }
        
        // 重新连接链表
        ListNode* newHead = newTail->next;
        newTail->next = nullptr;
        tail->next = head;
        
        return newHead;
    }
};
```

## 七、测试用例

```cpp
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

void testMatrixRotation() {
    cout << "=== 测试矩阵旋转 ===" << endl;
    
    // 测试1：3x3矩阵顺时针旋转
    {
        vector<vector<int>> matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        vector<vector<int>> expected = {
            {7, 4, 1},
            {8, 5, 2},
            {9, 6, 3}
        };
        
        MatrixRotator::rotateClockwise(matrix);
        assert(matrix == expected);
        cout << "测试1通过：3x3矩阵顺时针旋转" << endl;
    }
    
    // 测试2：4x4矩阵逆时针旋转
    {
        vector<vector<int>> matrix = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12},
            {13, 14, 15, 16}
        };
        
        vector<vector<int>> expected = {
            {4, 8, 12, 16},
            {3, 7, 11, 15},
            {2, 6, 10, 14},
            {1, 5, 9, 13}
        };
        
        MatrixRotator::rotateCounterClockwise(matrix);
        assert(matrix == expected);
        cout << "测试2通过：4x4矩阵逆时针旋转" << endl;
    }
    
    // 测试3：矩形矩阵旋转
    {
        vector<vector<int>> matrix = {
            {1, 2, 3},
            {4, 5, 6}
        };
        
        vector<vector<int>> expected = {
            {4, 1},
            {5, 2},
            {6, 3}
        };
        
        auto rotated = RectMatrixRotator::rotateClockwise(matrix);
        assert(rotated == expected);
        cout << "测试3通过：2x3矩阵顺时针旋转" << endl;
    }
    
    // 测试4：旋转180度
    {
        vector<vector<int>> matrix = {
            {1, 2},
            {3, 4}
        };
        
        vector<vector<int>> expected = {
            {4, 3},
            {2, 1}
        };
        
        MatrixRotator::rotate180(matrix);
        assert(matrix == expected);
        cout << "测试4通过：2x2矩阵旋转180度" << endl;
    }
    
    // 测试5：空矩阵
    {
        vector<vector<int>> matrix;
        MatrixRotator::rotateClockwise(matrix);
        assert(matrix.empty());
        cout << "测试5通过：空矩阵旋转" << endl;
    }
    
    // 测试6：1x1矩阵
    {
        vector<vector<int>> matrix = {{42}};
        MatrixRotator::rotateClockwise(matrix);
        assert(matrix[0][0] == 42);
        cout << "测试6通过：1x1矩阵旋转" << endl;
    }
    
    cout << "所有测试通过！" << endl;
}

int main() {
    testMatrixRotation();
    return 0;
}
```

## 八、性能分析和优化

### 1. **时间复杂度分析**
```cpp
/*
转置 + 反转方法：
- 转置：O(n²)（实际上只遍历了矩阵的一半）
- 反转每行：O(n²)
总时间复杂度：O(n²)

分层旋转方法：
- 每个元素只被访问一次：O(n²)

四元素交换方法：
- 每个元素只被访问一次：O(n²)

对于 n x n 矩阵，所有方法都是 O(n²) 时间复杂度
*/
```

### 2. **空间复杂度分析**
```cpp
/*
原地旋转方法：
- 转置 + 反转：O(1) 额外空间
- 分层旋转：O(1) 额外空间
- 四元素交换：O(1) 额外空间

非原地旋转方法（矩形矩阵）：
- 需要 O(m x n) 额外空间
*/
```

### 3. **优化技巧**
```cpp
// 1. 避免不必要的转置
// 2. 使用位运算交换元素（如果元素类型允许）
// 3. 循环展开优化
// 4. 使用缓存友好的访问模式

class OptimizedMatrixRotator {
public:
    // 优化版本：缓存友好的旋转
    static void rotateClockwiseOptimized(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 使用块优化：每次处理一个小块
        const int BLOCK_SIZE = 32;  // 根据CPU缓存大小调整
        
        for (int i = 0; i < n; i += BLOCK_SIZE) {
            for (int j = 0; j < n; j += BLOCK_SIZE) {
                // 处理当前块
                int i_end = min(i + BLOCK_SIZE, n);
                int j_end = min(j + BLOCK_SIZE, n);
                
                // 转置当前块
                for (int x = i; x < i_end; x++) {
                    for (int y = max(j, x + 1); y < j_end; y++) {
                        swap(matrix[x][y], matrix[y][x]);
                    }
                }
            }
        }
        
        // 反转每一行
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

## 九、实际应用场景

### 1. **图像处理**
```cpp
// 图像旋转是图像处理中的基本操作
class ImageRotator {
public:
    // 旋转图像（支持RGB图像）
    static vector<vector<vector<int>>> rotateImage(
        const vector<vector<vector<int>>>& image, // [height][width][3]
        int degrees) {
        
        int height = image.size();
        int width = image[0].size();
        
        // 根据角度确定新图像的尺寸
        int newHeight, newWidth;
        if (degrees % 180 == 0) {
            newHeight = height;
            newWidth = width;
        } else {
            newHeight = width;
            newWidth = height;
        }
        
        vector<vector<vector<int>>> rotated(
            newHeight, 
            vector<vector<int>>(newWidth, vector<int>(3))
        );
        
        // 旋转每个像素
        double rad = degrees * M_PI / 180.0;
        double cosA = cos(rad);
        double sinA = sin(rad);
        
        double centerX = (width - 1) / 2.0;
        double centerY = (height - 1) / 2.0;
        double newCenterX = (newWidth - 1) / 2.0;
        double newCenterY = (newHeight - 1) / 2.0;
        
        for (int y = 0; y < newHeight; y++) {
            for (int x = 0; x < newWidth; x++) {
                // 计算在原图像中的位置
                double dx = x - newCenterX;
                double dy = y - newCenterY;
                
                double srcX = dx * cosA + dy * sinA + centerX;
                double srcY = -dx * sinA + dy * cosA + centerY;
                
                int srcXi = round(srcX);
                int srcYi = round(srcY);
                
                // 检查边界
                if (srcXi >= 0 && srcXi < width && srcYi >= 0 && srcYi < height) {
                    rotated[y][x] = image[srcYi][srcXi];
                } else {
                    // 边界外填充黑色
                    rotated[y][x] = {0, 0, 0};
                }
            }
        }
        
        return rotated;
    }
};
```

### 2. **游戏开发中的旋转**
```cpp
// 游戏中的精灵或地图旋转
class GameRotation {
public:
    // 旋转游戏地图
    static vector<vector<char>> rotateMap(const vector<vector<char>>& map, int degrees) {
        int height = map.size();
        int width = map[0].size();
        
        // 简单处理：只支持90度的倍数
        degrees = ((degrees % 360) + 360) % 360;
        
        switch (degrees) {
            case 0:
                return map;
            case 90: {
                vector<vector<char>> rotated(width, vector<char>(height));
                for (int i = 0; i < height; i++) {
                    for (int j = 0; j < width; j++) {
                        rotated[j][height - 1 - i] = map[i][j];
                    }
                }
                return rotated;
            }
            case 180: {
                vector<vector<char>> rotated(height, vector<char>(width));
                for (int i = 0; i < height; i++) {
                    for (int j = 0; j < width; j++) {
                        rotated[height - 1 - i][width - 1 - j] = map[i][j];
                    }
                }
                return rotated;
            }
            case 270: {
                vector<vector<char>> rotated(width, vector<char>(height));
                for (int i = 0; i < height; i++) {
                    for (int j = 0; j < width; j++) {
                        rotated[width - 1 - j][i] = map[i][j];
                    }
                }
                return rotated;
            }
            default:
                throw invalid_argument("只支持90度的倍数");
        }
    }
};
```

## 十、总结

### 核心要点：
1. **顺时针旋转90度**：转置 + 反转每行
2. **逆时针旋转90度**：转置 + 反转每列
3. **旋转180度**：反转每行 + 反转每列
4. **原地旋转**：使用分层旋转或四元素交换
5. **矩形矩阵旋转**：需要创建新矩阵，尺寸会变化

### 选择建议：
- 对于正方形矩阵原地旋转：使用**转置+反转**方法（代码简洁）
- 需要最大性能：使用**分层旋转**（可能更缓存友好）
- 矩形矩阵：使用**坐标映射**方法创建新矩阵
- 任意角度旋转：使用**数学公式**但需要处理插值

### 注意事项：
1. 注意矩阵边界条件
2. 原地旋转时注意元素覆盖顺序
3. 对于大矩阵，考虑缓存优化
4. 矩形矩阵旋转后尺寸会变化

掌握矩阵旋转的算法是处理二维数据的基本技能，在图像处理、游戏开发、科学计算等领域都有广泛应用。